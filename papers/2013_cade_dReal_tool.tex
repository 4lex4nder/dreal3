\documentclass[envcountsect]{llncs}
%\usepackage{stmaryrd,amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage{amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage[ruled,lined,boxed,commentsnumbered,linesnumbered]{algorithm2e}
\newcommand{\dom}{\mathrm{dom}}
\newtheorem{notation}[theorem]{Notation}
\newcommand{\len}{\mathit{len}}
\newcommand{\poly}{\mathsf{poly}}

%\setlength{\textwidth}{5.7in}
%\setlength{\textheight}{8.2in}
%\setlength{\topmargin}{0in}
%\setlength{\oddsidemargin}{.4in}
%\setlength{\evensidemargin}{.4in}

\title{{\sf dReal}: an SMT Solver for Nonlinear Theories over the Reals}
\author{Sicun Gao \and Soonho Kong \and Edmund M. Clarke}
\institute{Carnegie Mellon University, Pittsburgh, PA 15213}

\begin{document}
\maketitle

\begin{abstract}
We present our open-source tool {\sf dReal}, an SMT solver for 
nonlinear formulas over the reals that can handle various nonlinear elementrary
functions. The tool is under the framework of $\delta$-complete decision
procedures, and returns {\sf unsat} or {\sf $\delta$-sat} on input formulas,
where $\delta$ can be specified by the user. When the answer is {\sf unsat},
{\sf dReal} produces a proof of unsatisfiability; when ``$\delta$-sat", it
provides a solution such that a $\delta$-perturbed form of the input formula is
satisfied. The tool is based on using Interval Constraint Propagation in the
DPLL(T) framework to handle nonlinearity, and is
designed to be easily extendable with other numerical algorithms.   
\end{abstract}

\section{Introduction}

SMT formulas over the real numbers can encode a wide range of problems in
theorem proving and formal verification. Such formulas are very hard to solve
when nonlinear functions are involved~\cite{}. Our recent work on
{$\delta$-complete decision procedures} provided a new general framework for
handling nonlinear SMT problems over the reals~\cite{}. We say a decision
procedure is {\em $\delta$-complete} for a set $S$ of formulas, where $\delta$
is any positive rational number, if for any $\varphi$ from $S$ the procedure
returns one of the following answers:
\begin{itemize}
 \item {\sf unsat}: $\varphi$ is unsatisfiable.
 \item {\sf $\delta$-sat}: $\varphi^{\delta}$ is satisfiable.
\end{itemize}
Here, $\varphi^{\delta}$ is a syntactic variation of $\varphi$ that encodes a
notion of numerical perturbation on logic formulas (more
details in Section \ref{review}.) Essentially, we allow such a procedure to
give answers with one-sided, $\delta$-bounded errors. With this relaxation,
$\delta$-complete decision procedures can fully exploit the
power of scalable numerical algorithms to solve nonlinear
problems, and at the same time provide suitable correctness
guarantees for many correctness-critical problems~\cite{}. 

\section{Usage}

\subsection{Input Format}

We accept formulas in the standard {\sf smt2} format~\cite{}, with the following
extensions. 

\subsubsection{Nonlinear Functions.} In addition to nonlinear arithmetic, we
allow the following transcedental functions to appear in the formula, used in
prefix form.
 $$\sin, \cos, \tan, \arcsin, \arccos, \arctan, \exp, \log, \mbox{pow}, ... $$
among others. More nonlinear functions can be added when needed, by providing
the corresponding numerical evaluation algorithms. In fact, we are working on
the support for various nonlinear ordinary differential equations. 
 
\subsubsection{Bound Declarations.} Bound information on variables, although not
mandatory, can help the solver to locate solutions quickly. The grammar is to
write, before the formula itself, a list of simple atomic formulas such as:
\begin{verbatim}
(assert (< 0 x)) 
\end{verbatim}
This will set $x\in (0, +\infty)$ at parsing time. In theory~\cite{}, our
decision procedure should only work for formulas with all the variables
(implicitly or explicitly) contained in bounded intervals. In practice, it is
not a requirement to bound all variables in the input formula, and the solver
can infer some. 

\subsubsection{Floating Numbers and Precision.} We allow floating-point numbers
to be used as constants in any part of the formula. Also, the user can set the
precision by writing
\begin{verbatim}
(set-info :precision 0.0001) 
\end{verbatim}
The default precision is $10^{-3}$, and it can also be set through command
line.  

\subsubsection{Example.}\label{example} The following is an example input file.
It is taken from the flyspeck project~\cite{} for the complete formal proof of
the Kepler Conjecture. 
 \begin{example} (Filename {\tt flyspeck/172.smt2}. Flyspeck {\tt ID (6096597438
b)})
 \begin{verbatim}
(set-logic QF_NRA)
(set-info :precision 0.001)
(declare-fun x () Real)
(assert (<= 3.0 x))
(assert (<= x 64.0))
(assert (not (> (- (* 2.0 3.14159265) (* 2.0 (* x (arcsin (* (cos
0.797) (sin (/ 3.14159265 x))))))) (+ (- 0.591 (* 0.0331 x))
(+ (* 0.506 (/ (- 1.26 1.0) (- 1.26 1.0))) 1.0)))))
(check-sat)
(exit)
\end{verbatim}
\end{example}

\subsection{Command Line Options}

{\sf dReal} does not depend on particular external libraries, except
{\tt Boost}~\cite{}. After building, the tool can be simply used through: 
\begin{verbatim}
dReal [--verbose] [--proof] [--precision <double>] <filename>
\end{verbatim}
The default output is {\sf unsat} or {\sf delta-sat}. When the flags are
enabled, the following output will be provided. 
\begin{itemize}
 \item If {\tt --verbose} is set, then the solver will output the detailed
decision traces along with the solving process. That is, it will print the
branch-and-prune trace in the constraint propagation procedures for checking
consistency of theory atoms, as well as DPLL-level
assert/check/backtracking operations. 
\item If {\tt --proof} is set, the solver produces an addition file
``{\tt filename.proof}'' upon termination, and provides the following
information. 
\begin{itemize}
\item If the answer is {\sf delta-sat},
then {\tt filename.proof} contains a witnessing solution, plugged into a
$\delta$-perturbation of the original formula, such
that the correctness can be easily checked externally. The theory of
$\delta$-perturbations will be explained in Section~\ref{deltas}. 

\item If the answer is {\sf unsat}, then {\tt filename.proof} contains a trace
of the solving steps, which can be verified as a proof tree that establishes the
unsatisfiability of the formula. This file can be the input of a stand-alone
proof checker, which will be explained in
Section~\cite{proof}
\end{itemize}
\item The {\tt --precision} flag gives the option of overwriting the
default precision, and the one set in the benchmark. 
\end{itemize}

\begin{example}
With default parameters, {\sf dReal} solves the formula in 
Example~\ref{example} in {\tt 10ms}, returning {\sf unsat}, on a machine with
a 32-core 2.3GHz AMD Opteron Processor and 94GB of RAM.
\end{example}

\subsection{Proof Certification}\label{proof}

When the {\tt --proof} flag is set, the solver produces a file that certifies
the answer. In the {\tt delta-sat} case, the solution is plugged in the
formula, and its correctness can be checked externally. For the {\tt unsat}
cases, we provide a proof checker that attempts to verify the proof. 

The proof checker is written in {\bf OCaml}, and uses the interval arithmetic
package~\cite{}. After we run {\sf dReal} and observe an {\sf unsat} answer,
the proof checker can be used as follows. 
\begin{verbatim}
proofcheck [--timeout <int>] <filename> 
\end{verbatim}
The proof checker will create a new folder called {\tt filename}, which
contains auxilary files needed. It is possible for the proof
checking procedure to produce an exponential amount of new files, so setting a
 timeout is important. By default, the timeout is {\tt 30min}. The proof
checker will return either ``{\sf proof verified}'' or ``{\sf timeout}''. 

\begin{example}
After {\sf dReal} returns that the formula in Example~\ref{example} is {\sf
unsat}, we run {\sf proofcheck} on the same machine. The proof checker returns
``{\sf proof verified}'' in 9.42s. {\bf todo number of loops, bla}. 
\end{example}




\section{Design}

\subsection{The $\delta$-Decision Problem}\label{deltas}

The standard decision problem is undecidable, for SMT formulas
over the reals with any trignometric function. If only polynomials are allowed,
then the problem is decidable in {\sf PSPACE}, but the practical algorithms have
double-exponential worst-case running time. In face of such difficulty, we
propose to focus on the so-called $\delta$-decision problem, which relaxes the
standard decision problem in the following way. Let $\delta$ be any positive
rational number. On a given SMT formula $\varphi$, we ask for one of the
following answers:
\begin{itemize}
 \item {\sf unsat}: $\varphi$ is unsatisfiable.
 \item {\sf $\delta$-sat}: $\varphi^{\delta}$ is satisfiable.
\end{itemize}
When the two cases overlap, either answer can be returned. Here,
$\varphi^{\delta}$ is called the $\delta$-perturbation (or $\delta$-weakening)
of $\varphi$, which has the following formal definition. 
\begin{definition}[$\delta$-Perturbations~\cite{}]
 Let $\delta\in \mathbb{Q}^+\cup\{0\}$ be a constant and $\varphi$ be a
$\Sigma_1$-sentence in standard form:
\[\varphi:= \exists^{\vec I}\vec x\;(\bigwedge_{i=1}^m (\bigvee_{j=1}^{k_i}
f_{ij}(\vec x)= 0)).
\]
The $\delta$-weakening of $\varphi$ defined as:
\[\varphi^{\delta}:= \exists^{\vec I} \vec x\;(\bigwedge_{i=1}^m(\bigvee_{j=1}^k
|f_{ij}(\vec x)|\leq \delta)).\]
\end{definition}
The fact that all SMT formulas can be put into this standard form is
straightforward~\cite{}. 

Solving the $\delta$-decision problem is as useful as the standard one, for many
correctness-critical problems~\cite{}. For instance, suppose we perform bounded
model checking on some hybrid system, and encode the safety properties as an SMT
formula $\varphi$. Then following standard model checking techniques, if we
decide that $\varphi$ is {\sf unsat}, then the system is indeed ``safe'' with in
some bounds; if we decide that $\varphi$ is {\sf $\delta$-sat}, then the system
would become ``unsafe'' under some $\delta$-perturbation on the system. In this
way, when $\delta$ is reasonably small, we have essentially taken into account 
the robustness properties of the system, and can justifiably conclude that the
system is unsafe in practice. 

It is important that the theoretical properties of the $\delta$-decision problem
provides us a new and positive outlook towards reasoning over the reals, as well
as a guiding framework for the development of practical decision procedures. We
proved that the $\delta$-decision problem is decidable for bounded formulas
containing any computable real functions~\cite{}, which is in essence any
function that can be numerically simulated. Also, the complexity bounds is
encouraging. For instance, bounded SMT problems for formulas with 



\subsection{DPLL$\langle$ICP$\rangle$}

\subsection{Proof Checking}

\section{Results}




\bibliographystyle{abbrv}
\bibliography{tau}
\end{document}

