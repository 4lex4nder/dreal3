\documentclass[envcountsect]{llncs}
%\usepackage{stmaryrd,amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage{amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage[ruled,lined,boxed,commentsnumbered,linesnumbered]{algorithm2e}
\newcommand{\dom}{\mathrm{dom}}
\newtheorem{notation}[theorem]{Notation}
\newcommand{\len}{\mathit{len}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\dreach}{{\tt dReach}}
%\setlength{\textwidth}{5.7in}
%\setlength{\textheight}{8.2in}
%\setlength{\topmargin}{0in}
%\setlength{\oddsidemargin}{.4in}
%\setlength{\evensidemargin}{.4in}

\newcommand{\flow}{\mathsf{flow}}
\newcommand{\jump}{\mathsf{jump}}
\newcommand{\inv}{\mathsf{inv}}
\newcommand{\init}{\mathsf{init}}
\newcommand{\guard}{\mathsf{guard}}
\newcommand{\reset}{\mathsf{reset}}
\newcommand{\reach}{\mathsf{Reach}}
\newcommand{\unsafe}{\mathsf{unsafe}}
\newcommand{\safe}{\mathsf{safe}}


\title{{\tt dReach}: A Reachability Analysis Tool for Nonlinear Hybrid Systems}
\author{Sicun Gao \and Soonho Kong \and Edmund M. Clarke}
\institute{Carnegie Mellon University, Pittsburgh, PA 15213}

\begin{document}
\maketitle

\begin{abstract}
We present our tool {\tt dReach} for bounded model checking
and invariant validation on nonlinear hybrid systems. The tool provides
correctness guarantees under the framework of $\delta$-complete reachability
analysis. For instance, for bounded model checking, if {\tt dReach} returns that
a system is ``safe'' within some bound, then the system is guaranteed to be safe
within the bound; on the other hand, if it returns ``$\delta$-unsafe'' (with a
counterexample trace), then there exists some $\delta$-bounded perturbation on the
system that would render it unsafe. Here, $\delta$ is a small numerical error
bound chosen by the user. In this framework, {\tt dReach} relies on logical
reasoning engines that can exploit the full power of various numerical
algorithms in a formal way, and can be scalable on nonlinear problems. 
We show experiments using {\tt dReach} to handle challenging nonlinear
benchmarks. 
\end{abstract}

\section{Introduction}

We introduce the tool {\tt dReach} for solving hybrid
system verification problems. Let $H$ be a hybrid system, whose description can
contain various nonlinear functions such as polynomials, trignometric
and exponential functions, and Lipschitz-continuous ODEs. Let $\delta\in
\mathbb{Q}^+$ be a user-selected error bound. The problems are:
\paragraph{Bounded Model Checking.} Let $n\in \mathbb{N}$ be a bound and
$T\in \mathbb{R}^+$ be an upper bound of time duration, and $U$ be a subset of
the state space of $H$. The bounded model checking problem asks whether $H$ can
reach $U$ within a time duration of $T$ and within $n$ steps of mode change.
{\tt dReach} returns one of the following answers:
\begin{itemize}
 \item $H$ can not reach $U$ in $n$ steps within time bound $T$. 
 \item $H^{\delta}$ can reach $U^{\delta}$ in $n$ steps within time bound $T$. 
\end{itemize}
\paragraph{Invariant Validation.} Let $Inv$ be a user-proposed inductive
invariant and $U$ a subset of the state space of $H$. The invariant validation
problem asks whether $Inv$ is an inductive invariant of $H$, which implies that
$H$ does not reach $U$. 
{\tt dReach} returns
one of the following answers:
\begin{itemize}
 \item $Inv$ is an inductive invariant for $H$, and $H$ can never reach $U$.
 \item $Inv^{\delta}$ is an inductive invariant for $H^{\delta}$. 
 \end{itemize}

When we write $H^{\delta}, U^{\delta}, Inv^{\delta}$ in the description, we
mean a $\delta$-perturbation on the first-order formulas that encode these
descriptions. This follows our framework of $\delta$-reachability
analysis~\cite{}. Essentially, 

\section{Using {\tt dReach}}
\begin{figure}[h!]
\label{dreach}
\begin{verbatim}
#file automata_example.drh
[1,10] x; [-10, 311] y; [0, 21] t;
%%
{   mode: 1;
    dynamics: [d/dt]x = x + y; [d/dt]y = x*y - 10;
    jump: x>10 ==> @2 (= x' (+ (* 5 x) y)); (< y 5) ==> @2 (= y' x*y);
}
{   mode: 2;
    dynamics: [d/dt]x = y; [d/dt]y = sin(x);
    jump: x<5 ==> @1 (= x' 1); y>10 ==> @2 (= y' 2);
}    
%%
x>10 | y<10 ;
\end{verbatim}
\caption{dReach file example automata\_example.drh}
\end{figure}

The input format of the tool is defined as follows. 
\begin{verbatim}
<variable_declarations>
%%
<automaton_declarations>
%%
<property_declarations>
\end{verbatim}

\paragraph{Variable Declarations.} Variables are declared first, which are
bounded by intervals that give a coarse estimate of their ranges. The infinity
signs can be used for variables whose ranges can be inferred from other
variables.
\begin{verbatim}
[lower_bound, upper_bound] variable_name;
\end{verbatim}
The lower\_bound and upper\_bound are floating point numbers. 

For instance,
\begin{verbatim}
[-1000.1, 1.2e+12] x;
\end{verbatim}
declares variable $x$ to be a real number in the interval $x\in [-1000.1,
1.2\times 10^{12}].$

\paragraph{Automaton Declarations.}

Hybrid automata are finite automata with continuous variables; the continuous
variables can follow different dynamics in each location. In each location, we
need to specify the dynamics and constraints on the transitions between the
modes. 

Each mode is given as a block in the automata declaration:
\begin{verbatim}
{  	mode: i;
    dynamics: <continuous_equations>;
    jump: <transition_rules>; }
\end{verbatim}
The dynamics are usually given by differential equations. For instance,
\begin{verbatim}
[d/dt]x = x*y + y;
[d/dt]y = sin(x);
\end{verbatim}
The transition rules are given as follows. Suppose $x$ is a variable, we write
the updated value of $x$ as $x'$. The rules specify the next control location as
well as the updated variables. The rules are written using format:
\begin{verbatim}
<guard_conditions> ==> @location <reset_conditions>
\end{verbatim}
For instance,
\begin{verbatim}
(and (> x 10)  (< y 5)) ==> @i (and (= x' (+ x y)) (= y' (sin x)) ; 
\end{verbatim}

\paragraph{Property Declarations.}

Safety properties can be given by any first-order formula. For instance
\begin{verbatim}
x < 10 & y+x^2 > 5;
\end{verbatim}
is a legitimate safety property. 

\newpage

\section{Compact Format}

\begin{verbatim}
<variable_declaration>
%%
<automaton_declaration>
%%
<property_declaration>
\end{verbatim}
$\flow$ is given for each mode separately. 
\begin{verbatim}
flow:
@1
{
[d/dt] x = y;
[d/dt] y = (* 2 x);
}

@2
{
[d/dt] x = (- 1 y);
[d/dt] y = x;
}
\end{verbatim}
$\jump$ is given as follows.
\begin{verbatim}
jump:
(> x 0) ==> @2 (and (= x' x) (= y' x));
(< x 0) ==> @1 (= x' x);
\end{verbatim}
Note that when the assumptions overlap, it means a nondeterministic choice, not
with respet to the mode itself. Note that the assumptions do not have numbers
in them. 

The invariant conditions are coupled with the flows. 
\begin{verbatim}
inv:
@1 (> x 0);
@2 (< y 0);
\end{verbatim}
The initial conditions is
\begin{verbatim}
init:
@1 (< x 0);
\end{verbatim}


\paragraph{Unwinding} The automaton is unrolled as follows. 

Suppose there are $m$ modes. Suppose we have invariants but do not check them
until the end points. 

The transition relation is the following formula
$$\mathsf{Trans}(\vec x_i^t, \vec x_{i+1}^t) = \bigvee_{j=1}^m (\jump_j(\vec
x_i^t, \vec x_{i+1}) \wedge \flow_j(\vec x_{i+1}, \vec x_{i+1}^t, t_{i+1})
\wedge \inv_j(\vec x_{i+1}^t))$$
and the whole formula is
$$\reach_{k} = \init(\vec x_0)\wedge \flow_1(\vec x_0, \vec x_0^t)\wedge 
\bigwedge_{i=0}^{k-1} \mathsf{Trans}(\vec x_i^t, \vec x_{i+1}^t)\wedge
\unsafe(\vec x_{k}^t)$$

In all, an example:
\begin{figure}[h!]
\label{dreach}
\begin{verbatim}
#file compact_automata_example.drh
[1,10] x; [-10, 311] y; [0, 21] t;
%%
flow:
@1
{
[d/dt] x = y;
[d/dt] y = (* 2 x);
}

@2
{
[d/dt] x = (- 1 y);
[d/dt] y = x;
}
jump:
(> x 0) ==> @2 (and (= x' x) (= y' x));
(< x 0) ==> @1 (= x' x);
inv:
@1 (> x 0);
@2 (< y 0);
init:
@1 (< x 0);
%%
goal:
(< x 0);
\end{verbatim}
\caption{Compact dReach file example automata\_example.drh}
\end{figure}






\newpage
\section{Design and Implementation}

{\tt dReach} consists of a front end that encodes the verification problems
using first-order formulas, and a backend SMT solvers that provide
$\delta$-decisions on the formulas.

\subsection{$\delta$-Complete Methods}

\subsection{Encoding Bounded Model Checking}

\subsection{Encoding Invariant Validation}






\subsection{The Underlying Decision Procedures}


\section{Examples}


\bibliographystyle{abbrv}
\bibliography{tau}
\end{document}

