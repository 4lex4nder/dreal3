\documentclass[envcountsect]{llncs}

\usepackage{stmaryrd,amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage[ruled,lined,boxed,commentsnumbered,linesnumbered]{algorithm2e}

\newtheorem{notation}[theorem]{Notation}

\newcommand{\dom}{\mathrm{dom}}
\newcommand{\len}{\mathit{len}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\flow}{\mathsf{flow}}
\newcommand{\jump}{\mathsf{jump}}
\newcommand{\inv}{\mathsf{inv}}
\newcommand{\init}{\mathsf{init}}
\newcommand{\guard}{\mathsf{guard}}
\newcommand{\reset}{\mathsf{reset}}
\newcommand{\reach}{\mathsf{Reach}}
\newcommand{\unsafe}{\mathsf{unsafe}}
\newcommand{\safe}{\mathsf{safe}}
\newcommand{\p}{\mathsf{P}}
\newcommand{\np}{\mathsf{NP}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\lrf}{\mathcal{L}_{\mathbb{R}_{\mathcal{F}}}}
%\setlength{\textwidth}{5.1in}
%\setlength{\textheight}{8.2in}
%\setlength{\topmargin}{0in}
%\setlength{\oddsidemargin}{.7in}
%\setlength{\evensidemargin}{.7in}

\title{Bounded $\delta$-Reachability for Hybrid Systems}
\author{Sicun Gao \and Soonho Kong \and Edmund M. Clarke}
\institute{Carnegie Mellon University, Pittsburgh, PA 15213}

\begin{document}
\maketitle

\begin{abstract}
We study the bounded ``$\delta$-reachability'' problem for hybrid systems. Let
$\delta$ denote a desirable error bound, we say a hybrid system $H$ can
$\delta$-reach a set $U$ if under some $\delta$-perturbation, $H^{\delta}$
reaches $U^{\delta}$, which are formally defined on their representations given
by first-order formulas over the reals. We show that the bounded
$\delta$-reachability problem for a wide range of nonlinear hybrid systems can
be solved, using our recent results of bounded $\delta$-decidability of
first-order theories over the reals with arbitrary computable real functions
(polynomials, transcendental functions, nonlinear ODEs, etc.). Following this
new framework, practical verification
tools can be developed using decision procedures over the reals that exploit
the full power of numerical algorithms in a formal way. We show promising
experimental results on nonlinear hybrid systems. 

\end{abstract}

\section{Introduction}

Hybrid systems model the tight coupling of discrete and continuous components
in cyber-physical systems. Formal verification of hybrid systems is
important and challenging. It is well known that safety verification
problems for hybrid systems with very simple dynamics are
undecidable~\cite{DBLP:journals/tse/AlurHH96,DBLP:journals/jcss/HenzingerKPV98,
DBLP:journals/tcs/Bournez99}. In practice, systems
with constant-rate dynamics
and some systems with linear dynamics (but simple discrete control structures)
can be handled
algorithmically~\cite{DBLP:journals/tse/AlurHH96,lpw:sttt97,DBLP:conf/hybrid/ChutinanK99,DBLP:conf/hybrid/AsarinDMB00,DBLP:conf/cav/AsarinDM02,DBLP:conf/hybrid/GirardGM06,DBLP:conf/cav/GuernicG09}; proof-theoretic
approaches can verify some nonlinear systems after manual analysis~\cite{DBLP:journals/logcom/Platzer10,DBLP:conf/hybrid/Sankaranarayanan10}.
However, the gap between existing technology
and the goal of automatic verification of realistic hybrid systems of a
reasonable scale is still wide. 

A key bottleneck problem for hybrid systems verification is to determine the
truth
value of first-order sentences over the reals with nonlinear real functions,
which is well-known to be a very hard or undecidable problem~\cite{}. Recently
we have developed a new framework to study the ``$\delta$-decision'' problem
instead~\cite{}, asking for answers that may have one-sided $\delta$-bounded
errors. That is, given a first-order sentence $\varphi$, we ask whether
$\varphi$ is false, or some $\delta$-relaxation of $\varphi$ is true, which is
defined as a slight syntactic variation of $\varphi$. We proved the
$\delta$-decidabilty of bounded first-order sentences over the reals with
arbitrary computable real functions (as
defined in computable analysis~\cite{CAbook}, including polynomials,
transcendental functions, solutions of Lipschitz-continuous ODEs, etc.).
This framework leads to the development of numerically-driven decision
procedures that exploit the full power of efficient numerical algorithms in a
formal way, with very promising performance~\cite{}.

In this paper, we show how to apply the $\delta$-decision framework to
hybrid system verification. We study the problem of bounded
$\delta$-reachability, which can be encoded as decision
problems over the reals, for a wide range of nonlinear hybrid systems. 

First of all, our study of first-order formulas with arbitrary computable real
functions equips us with a rich language for describing hybrid systems in
general. We define $\lrf$-representable hybrid systems, where $\mathcal{F}$ can
be any set of computable real functions. The classes of hybrid systems that have
been studied in the existing literature can all be easily defined by restricting
$\mathcal{F}$. We define the notion of perturbations on hybrid
systems as syntactic perturbations on their $\lrf$-representations, which
 will provide the key link to $\delta$-decidability results. 

Second, we define the $\delta$-reachability problem as a slight
relaxation of the standard reachability problem. Let $\delta\in \mathbb{Q}^+$ be
arbitrary. Give a hybrid system $H$ and a region $U$ of its state
space, both $\lrf$-represented, the $\delta$-reachability problem asks for
one of the following two answers:
\begin{itemize}
 \item {\sf safe}: $H$ can not reach $U$.
 \item {\sf $\delta$-unsafe}: Under some $\delta$-perturbation, $H^{\delta}$ can
reach $U^{\delta}$. 
\end{itemize}
These answers are in fact not weaker than the precise ones for
verification purposes. When {\sf safe} is the answer, we know for certain
that $H$ does not reach the unsafe region; when {\sf $\delta$-unsafe} is the
answer, there exists some $\delta$-bounded perturbation in the
system that {\em would} render it unsafe. Note that the error-bound $\delta$ can
be chosen to be arbitrarily small, so that the {\sf$\delta$-unsafe} answer
discovers robustness problem in the system, which should be regarded as unsafe
indeed. We encode the checking of bounded $\delta$-reachability as
$\lrf$-sentences. As a consequence, we can prove that the bounded
$\delta$-reachability problem is decidable for arbitrary
$\lrf$-representable hybrid systems, with complexity bounds $\mathsf{NP^C}$
(trivial invariants) and $\mathsf{(\Sigma_2^P)^C}$ (general case) where
$\mathsf{C}$ is the complexity class that $\mathcal{F}$ lies in. Compared to the
 undecidability of standard bounded reachability of very simple hybrid systems,
the results lead to a new outlook for general hybrid system
verification. 

Third, the new framework directly leads to practical solving techniques. Using a
powerful decision procedure, we perform bounded model checking on nonlinear
hybrid systems that contain many transcendental
functions and nonlinear ODEs, and show the promising experimental results. 

The paper is organized as follows. First, in
Section~\ref{review}, we review the background framework of
computable real functions and $\delta$-decisions for first-order formulas. We
then define $\lrf$-representations of hybrid systems and define perturbations
on them, in Section~\ref{language}. We
study the bounded $\delta$-reachability problem in
Section~\ref{main}, proving decidability and complexity bounds, through their
encodings as $\lrf$-formulas. We discuss related work in detail in
Section~\ref{}, show experimental results on nonlinear hybrid systems
in Section~\ref{experiments}. We point out further implications and conclude in
Section~\ref{conclude}.

\section{A Brief Review of $\delta$-Decidability over the Reals}\label{review}

We first briefly review our framework of $\delta$-decision problems for
first-order sentences over the reals with computable real functions. More
details can be found in~\cite{}. 

To formalize computations over the reals, we first need to encode the real
numbers, as infinite strings. We can then model computations of real functions
with machines that can use infinite strings as input and output. That is, a real
function is computable if there exists a machine that computes, using oracles
that encode the arguments of the function, the values of the function to an
arbitrary precision. The following formal definitions are standard in 
computable
analysis~\cite{CAbook}.
\begin{definition}[Encoding Real Numbers]
A {\em name} of a real number $a\in \mathbb{R}$ is a function
$\mathcal{\gamma}_a: \mathbb{N}\rightarrow \mathbb{Q}$ satisfying that for all
$i\in \mathbb{N}$, $|\gamma_a(i) - a|<2^{-i}.$ For $\vec a\in \mathbb{R}^n$,
$\gamma_{\vec a}(i) = \langle \gamma_{a_1}(i), ..., \gamma_{a_n}(i)\rangle$, and
$\Gamma(\vec a) = \{\gamma: \gamma\mbox{ is a name of }\vec a\}$.
\end{definition}
\begin{definition}[Computable Real Functions] We say
$f:\subseteq\mathbb{R}^n\rightarrow \mathbb{R}$ is computable, if there exists
an oracle Turing machine $\mathcal{M}_f$ as follows. Let $\vec a\in
\dom(f)$ be any argument of $f$ and $\gamma(\vec a)$
any name of $\vec a$. On any input $i\in \mathbb{N}$,
$\mathcal{M}_f^{\gamma(\vec a)}(i)$ uses $\gamma(\vec a)$ as an oracle, and
computes a $2^{-i}$-approximation to $f(\vec a)$.
\end{definition}

Most common continuous real functions are computable, such as addition,
multiplication,  absolute value, $\min$, $\max$, $\exp$, $\sin$ and solutions of
Lipschitz-continuous ordinary differential equations. Compositions
of computable functions are computable. In fact, the notion of computability of
real functions directly corresponds to whether they can be numerically
simulated. This makes the theory directly applicable to almost all practical
hybrid systems. 

We consider first-order formulas with computable real functions interpreted
over the reals. We write $\mathcal{F}$ to denote an arbitrary collection of
symbols representing computable functions over $\mathbb{R}^n$ for various
$n$. Constants are seen as 0-ary functions. We always assume that
$\mathcal{F}$ contains at least $0$, unary negation, addition, and
the absolute value.  Let $\mathcal{L_{\mathcal{F}}}$ be the signature $\langle
\mathcal{F}, >\rangle$. $\lrf$-formulas are evaluated in the standard way over
the corresponding structure $\mathbb{R}_{\mathcal{F}}= \langle \mathbb{R},
\mathcal{F}, >\rangle$.  It is
not hard to see that we only need to use atomic formulas of the form
$t(x_1,...,x_n)>0$ or $t(x_1,...,x_n)\geq 0$, where $t(x_1,...,x_n)$ are built
up from functions in $\mathcal{F}$. To avoid extra preprocessing of formulas, we
give an explicit definition of $\lrf$-formulas as follows.
\begin{definition}[$\lrf$-Formulas]
Let $\mathcal{F}$ be a collection of Type 2 functions, which contains at least
$0$, unary negation -, addition $+$, and absolute value $|\cdot|$. We define:
\begin{align*}
t& := x \; | \; f(t(\vec x)), \mbox{ where }f\in \mathcal{F}\mbox{, possibly
constant};\\
\varphi& := t(\vec x)> 0 \; | \; t(\vec x)\geq 0 \; | \; \varphi\wedge\varphi
\; | \; \varphi\vee\varphi \; | \; \exists x_i\varphi \; |\; \forall x_i\varphi.
\end{align*}
In this setting $\neg\varphi$ is regarded as an inductively defined operation
which replaces atomic formulas $t>0$ with $-t\geq 0$, atomic formulas $t\geq 0$
with $-t>0$, switches $\wedge$ and $\vee$, and switches $\forall$ and $\exists$.
Implication $\varphi_1\rightarrow\varphi_2$ is defined as
$\neg\varphi_1\vee\varphi_2$.
\end{definition}
\begin{definition}[Bounded Quantifiers]
We define
\begin{align*}
\exists^{[u,v]}x.\varphi &=_{df}\exists x. ( u \leq x \land x \leq v \wedge
\varphi),\\
\forall^{[u,v]}x.\varphi &=_{df} \forall x. ( (u \leq x \land x \leq v)
\rightarrow \varphi),
\end{align*}
where $u$ and $v$ denote $\lrf$ terms whose variables only
contain free variables in $\varphi$, excluding $x$. It is easy to check that
$\exists^{[u,v]}x. \varphi \leftrightarrow \neg \forall^{[u,v]}x. \neg\varphi$.
\end{definition}
We say a sentence is bounded if it only involves bounded quantifiers.
\begin{definition}[Bounded $\lrf$-Sentences]
A {\em bounded $\lrf$-sentence} is
$$Q_1^{[u_1,v_1]}x_1\cdots Q_n^{[u_n,v_n]}x_n\;\psi(x_1,...,x_n).$$
$Q_i^{[u_i,v_i]}$s are bounded quantifiers, and $\psi(x_1,...,x_n)$ is a
quantifier-free $\lrf$-formula.
\end{definition}
We write $\psi(x_1,...,x_n)$ as $\psi[t_1(\vec
x)>0,...,t_k(\vec x)>0; t_{k+1}(\vec x)\geq 0,...,t_m(\vec
x)\geq 0]$ to emphasize that $\psi(\vec x)$ is a Boolean
combination of the atomic formulas shown. 
\begin{definition}[$\delta$-Variants]\label{variants}
Let $\delta\in \mathbb{Q}^+\cup\{0\}$, and $\varphi$ an
$\lrf$-formula of the form
$$\varphi: \ Q_1^{I_1}x_1\cdots Q_n^{I_n}x_n\;\psi[t_i(\vec x, \vec y)>0;
t_j(\vec x, \vec
y)\geq 0],$$ where $i\in\{1,...k\}$ and $j\in\{k+1,...,m\}$. The {\em
$\delta$-weakening} $\varphi^{\delta}$ of $\varphi$ is
defined as the result of replacing each atom $t_i > 0$ by $t_i >
-\delta$ and $t_j \geq 0$ by $t_j \geq -\delta$. That is, 
$$\varphi^{\delta}:\ Q_1^{I_1}x_1\cdots Q_n^{I_n}x_n\;\psi[t_i(\vec x, \vec
y)>-\delta; t_j(\vec x,
\vec y)\geq -\delta].$$
\end{definition}

We then have the following main decidability result. 
\begin{theorem}[$\delta$-Decidability] Let $\delta\in\mathbb{Q}^+$ be
arbitrary. There is an algorithm which, given any bounded $\varphi$,
correctly returns one of the following two answers:
\begin{itemize}
\item ``$\delta$-$\mathsf{True}$'': $\varphi^{\delta}$ is true.
\item ``$\mathsf{False}$'': $\varphi$ is false.
\end{itemize}
Note when the two cases overlap, either answer is correct. 
\end{theorem}
We call this new decision problem the $\delta$-decision problem for
$\lrf$-sentences. We proved the following complexity results. 
\begin{theorem}[Complexity]\label{compmain}
Let $\mathcal{F}$ be a class of computable functions. Let $S$ be a class of
$\lrf$-sentences, such that for any $\varphi$ in $S$, the
terms in $\varphi$ are computable in complexity class $\mathsf{C}$ where
$\mathsf{P\subseteq \mathsf{C}\subseteq \mathsf{PSPACE}}$.
Then, for any $\delta\in \mathbb{Q}^+$, the $\delta$-decision problem for
bounded $\Sigma_n$-sentences in $S$ is in $\mathsf{(\Sigma_n^P)^C}$.
\end{theorem}

\section{Hybrid Systems with $\lrf$-Representations}\label{language}

We give a precise syntax and semantics of hybrid systems using
$\lrf$-formulas and their interpretations, and then define the notion of
$\delta$-perturbations on them. 

\subsection{Basic Definitions}
A standard definition of general hybrid systems is as follows~\cite{}. 
\begin{definition}[Hybrid Automata]\label{auto-def}
An $n$-dimensional hybrid automaton is a tuple $H   = \langle X, Q, \flow,
\guard, \reset, \inv, \init\rangle$ that contains the following elements. 
\paragraph{\bf State Space.} $X\subseteq \mathbb{R}^n$ specifies the range of
the {\em continuous variables}  $\vec x$ of the system. $Q=\{q_0,...,q_m\}$ is
a finite set of discrete {\em control modes}.

\paragraph{\bf Continuous Components.} $\flow \subseteq Q\times
X\times \R \times X$ specifies the {\em continuous dynamics}
for each mode: $(q, \vec a_0, t, \vec a_t)\in \flow$, if in mode $q$,
there is a continuous flow from $\vec x =\vec a_0$ to $\vec x = \vec a_t$
after a time duration of $t$.

The $\flow$ predicate is usually defined either as explicit mappings from
$\vec a_0$ and $t$ to $\vec a_t$,  or as solutions of systems of differential
equations/inclusions that specify the derivative of $\vec x$ over time, with
initial conditions given by $\vec x_0$.

\paragraph{\bf Discrete Components.} $\jump\subseteq Q\times
X\times Q\times X$ specifies the {\em jump conditions}
between two modes: $(q,q',\vec a,\vec a')\in \jump$ if in mode $q$,
when the continuous variables are of value $\vec x = \vec a$, the automaton may
switch to mode $q'$, and set the continuous variables to $\vec x = \vec
a'$.  

\paragraph{\bf Initial and Invariant Conditions.} $\inv \subseteq Q\times X$
specifies the {\em invariant conditions} for
the system to stay in a control mode: $(q,\vec a)\in \inv$, if when the
automaton is in mode $q$, $\vec x = \vec a$ is a possible value for its
continuous variables.

$\init \subseteq Q\times X$ specifies the set of {\em
initial configurations} of the system: $(q, \vec a)\in \init$, if the
automaton can start from an initial configuration $\vec x = \vec a$ in mode
$q$.\} Without loss of generality, we always set $q=q_0$ in $\init$. (When there
are multiple initial modes, an additional mode can be
added to act as the only initial mode.)
\end{definition}
According to the definition, a hybrid automaton can be nondeterministic in
various ways.  The $\flow$ and $\jump$ conditions are not
restricted to single-valued functions.
\begin{remark}[$\jump$ vs $\inv$] The jump conditions specify when an automaton
{\em may}  switch to another mode. The invariants (when violated) specify when
an automaton {\em must} switch to another mode. All may-jumps can
be reduced to nondeterministic must-jumps. However, they will give rise to
different logical structures. See Section~\ref{encode}. 
\end{remark}
\begin{definition}\index{Invariant-free
Hybrid Automata}
A hybrid automata $H = \langle X, Q, \flow, \jump, \inv, \init\rangle$ is
 {\em invariant-free} if $\inv = Q\times X$, and we say the invariant is {\em
trivial} in this case.
\end{definition}

\subsection{$\lrf$-Representations}

We now define logical representations of hybrid systems. It is a general
formal representation that can express almost any hybrid system that models
realistic systems. 

\begin{definition}[$\lrf$-Representations]\label{lrf-definition}
\index{$\lrf$-Representation}
Let $H$ be an $n$-dimensional hybrid automaton.  Let $\mathcal{F}$
be a set of real functions, and $\mathcal{L}_{\mathbb{R}_{\mathcal{F}}}$ the
corresponding first-order language. We say that $H$ has an
$\lrf$-representation, if for every $q,q'\in Q$, there exists  quantifier-free
$\lrf$-formulas $$\phi^q_{\flow}(\vec x, \vec x_0, t), \phi^{q\rightarrow
q'}_{\jump}(\vec x,
\vec x'), \phi^{q}_{\inv}(\vec x), \phi^q_{\init}(\vec x)$$
such that for all
$\vec a ,\vec a'\in \mathbb{R}^n$,
$t\in\mathbb{R}$:
\begin{itemize}
\item $\mathbb{R}\models \phi^q_{\flow}(\vec a, \vec a', t)$ iff $(q, \vec
a,
\vec a', t)\in \flow$.
\item $\mathbb{R}\models \phi^{q\rightarrow q'}_{\jump}(\vec a, \vec a')$ iff
$(q, q', \vec a, \vec a')\in \jump$.
\item $\mathbb{R}\models \phi^q_{\inv}(\vec a)$ iff $(q, \vec a)\in \inv.$
\item $\mathbb{R}\models \phi^q_{\init}(\vec a)$ iff $q = q_0$ and $\vec a\in
\init_{q_0}$.
\end{itemize}
We can write $H = \langle X, Q, \phi_{\flow}, \phi_{\jump}, \phi_{\inv},
\phi_{\init}\rangle$ to emphasize that $H$ is represented in this way. But for
notational simplicity, when
the context is clear, we simply write $\flow, \jump, \inv, \init$ to denote
these logic formulas.
\end{definition}

\begin{remark}
We have not restricted the structures of the formulas defining each
predicate. This makes the definition more general
than necessary. For instance, the flow should be a continuous mapping from $\vec
x_0$ and $t$ to $\vec x_t$, and thus $\phi^q_{\flow}(\vec a,
\vec a_0, t)$ is usually a conjunction of equations of the form $\vec x_t =
f(\vec x_0, t)$, instead of arbitrary formulas. Different classes of hybrid
systems can be defined by refining this definition.
\end{remark}

\begin{definition}[Computable Representation]
We say a hybrid automaton $H$ has a {\em computable representation}, if $H$ has
an $\lrf$-representation, where $\mathcal{F}$ is an arbitrary set of computable
functions.
\end{definition}
$\mathcal{F}$ can contain arbitrary computable functions, such as
polynomials, transcendental functions, Lipschitz-continuous ODEs and many PDEs.
\begin{remark}[{\bf todo}]
Special note is needed for flows defined by ODEs. A system of ODEs is not a
computable function itself, but its solutions. Of course, we do not express the
function analytically. 
\end{remark}

We now formally specify the semantics. Combining continuous and discrete
behaviors, the trajectories of hybrid systems are {\em piecewise continuous}.
This motivates a two-dimensional structure of time~\cite{}, with which we can
keep track of both the discrete changes and the duration of each continuous
flow.
\begin{definition}[Hybrid time domain]
A {\em hybrid time domain} $T$ is a subset of
 $\mathbb{N}\times \mathbb{R}$ of the form
$T_m=\{(i, t): i<m \mbox{ and } t\in [t_i, t_i']\mbox{ or }[t_i, +\infty)\},$
where $m\in \mathbb{N}\cup\{+\infty\}$, $\{t_i\}_{i=0}^m$ is an
increasing sequence in $\mathbb{R}^+$, $t_0= 0$, and $t_i'=t_{i+1}$.
\end{definition}
We write the set of all hybrid time domains as $\mathbb{H}$.
\begin{definition}[Hybrid Trajectories]
Let $X\subseteq\mathbb{R}^n$ be an Euclidean space and $T_m$ a hybrid
time domain. A {\em hybrid trajectory} is any continuous function $\xi: T_m
\rightarrow X.$
 \end{definition}
We write $\Xi_X$ to denote the set of all possible hybrid trajectories from
$\mathbb{H}$ to $X$.
 \begin{remark}
Note that the trajectories become continuous because of the discrete component
in $T$. More details of the topological structures are in the
Appendix. A two-dimensional time domain avoids ``break points'' on the
continuous dimension. At the discrete change points, $(i,t_i')$ and $(i+1,
t_{i+1})$ are distinguished by the first coordinate, and the time intervals for
each $i$ can
always include both endpoints.
\end{remark}

We can now define trajectories of a given hybrid automaton. The intuition behind
the following definition is straightforward. The labeling function
$\sigma_{\xi}^H(i)$ is used to map a step $i$ to the corresponding discrete mode
in $H$. In each mode, the system flows continuously following the dynamics
defined by $\flow(q, \vec x_0, t)$. Note that $(t-t_k)$ is the actual duration
in the $k$-th mode. When a switch between two modes is performed, it is required
that $\xi(k+1, t_{k+1})$ is updated from the exit value $\xi(k, t_k')$ in the
previous mode, following the jump conditions.

\begin{definition}[Trajectories of a Hybrid Automaton]\label{trajec}
Let $H$ be a hybrid automaton, and $\xi: T_m\rightarrow X$ a hybrid trajectory.
We say that $\xi$ is {\em a trajectory of $H$ of discrete depth $m$}, if there
exists a {\em labeling function} $\sigma^H_{\xi}: \mathbb{N}\rightarrow Q$ such
that:
\begin{itemize}
\item $\sigma^H_{\xi}(0) = q_0$ and
$\mathbb{R}_{\mathcal{F}}\models \init_{q_0}(\xi(0,0))$;
\item For any $(i, t)\in T_m$,
$\mathbb{R}_{\mathcal{F}}\models \inv_{\sigma^H_{\xi}(i)} (\xi(i,t))$;
\item When $i=0$,
$$\mathbb{R}_{\mathcal{F}}\models\flow_{q_0}(\xi(0,0), \xi(0,t), t).$$
\item When $i = k+1$, where $0< k+1 <m$,
\begin{eqnarray*}
\mathbb{R}_{\mathcal{F}}&\models&\flow_{\sigma^H_{\xi}(k+1)}(\xi(k+1, t_{k+1}),
\xi(k+1, t), (t - t_{k+1}))\mbox{ and }\\
\mathbb{R}_{\mathcal{F}}&\models& \jump_{(\sigma^H(k)\rightarrow
\sigma^H(k+1))}(\xi(k, t_k'), \xi(k+1,t_{k+1})).
\end{eqnarray*}
\end{itemize}
\end{definition}
We write $\llbracket H\rrbracket$ to denote the set of all possible trajectories
of $H$.

\subsection{Reachability and Safety Verification}

The safety/reachability problem for hybrid systems can be stated formally as
follows. 
\begin{definition}[Reachability]\label{reachability}\index{Reachability}
Let $H$ be an $n$-dimensional hybrid automaton, and $U$ a subset of its state
space $Q\times X$.  We say {\em $U$ is reachable by $H$}, if there exists
$\xi\in\llbracket
H \rrbracket$ with its time domain $T$ and labeling function
$\sigma_{\xi}^H$, such that there exists $(i,t)\in T$ satisfying
$(\sigma^H_{\xi}(i), \xi(i,t))\in U.$ When we only ask whether a subset of the
Euclidean space is reachable, it means whether the region is reachable in any
discrete mode.
\end{definition}
In the seminal work of \cite{DBLP:conf/rex/AlurD91,DBLP:conf/hybrid/AlurCHH92},
it is already shown that the reachability problem for simple classes of hybrid
automata is already undecidable. In fact, clear boundaries of the decidable and
undecidable classes has been given~\cite{DBLP:journals/jcss/HenzingerKPV98}.

\begin{definition}[Linear Hybrid Automata]
Let $\mathcal{F} = \{+\}\cup \mathbb{Q}$ (the rational numbers are considered as
 0-ary functions). We say a hybrid automaton $H$ is a {\em linear hybrid
automaton} if it has an $\lrf$-representation.
\end{definition}

\begin{proposition}[Undecidability for LHA~\cite{DBLP:conf/hybrid/AlurCHH92,}]
The bounded reachability problem for linear hybrid automata is undecidable.
\end{proposition}
It is standard in the existing literature that all the constants used in the
description of a hybrid automaton are rational, so that symbolic algorithms can
be used. We avoid such restrictions and allow any
computable signature $\mathcal{F}$, which means  any computable real numbers
can be used as constants in the description of hybrid automata. It is worth
noting that allowing arbitrary computable reals itself would already render the
reachability problem for even more trivial classes of hybrid automata
to be undecidable. Indeed, since the equality test $x=a$ is
undecidable~\cite{CAbook},
the question of whether a flow of $dx/dt = 1$ can reach some point $a$ is
undecidable already. 

\section{Bounded $\delta$-Reachability}\label{main}

In this section we study the bounded $\delta$-reachability problem. We encode
the problem into $\lrf$-formulas through standard bounded model checking, and
then prove its decidability and complexity bounds for general
$\lrf$-represetable hybrid systems. 

\subsection{Encoding Bounded Reachability}\label{encode}

The bounded reachability problem for hybrid systems is defined by restricting
the continuous components and time duration to a bounded domain, and the number
of discrete transitions to a finite number. 
\begin{definition}[($k$,$M$)-Bounded Reachability]
Let $H$ be an $n$-dimensional hybrid automaton, whose continuous state space
$X$ is a bounded subset of $\mathbb{R}^n$. Let $U$ be a subset of its state
space. Let $k\in \mathbb{N}$ and $M \in \mathbb{R}$. The {bounded
reachability problem} (or {\em $(k,M)$-reachability}) asks whether there exists
$\xi\in\llbracket H \rrbracket$ with its time domain $T$ and a labeling function
$\sigma_{\xi}^H$, such that there exists $(i,t)\in T$ with $i\leq k$, $t=
\sum_{i=0}^k t_i$ where $t_i \leq M$, and $(\sigma^H_{\xi}(i), \xi(i,t))\in U.$ 
\end{definition}
\begin{remark}
In the definition, we require all the continuous variables (including
time), as well as the number of discrete transitions. This is because our
framework only deals with bounded $\lrf$-formulas (and of course, with finite
length). Multiple weaker notions can be defined, by relaxing some of these
bounds (such as bounded discrete steps but unbounded time.) However, any such
relaxation will still lead to undecidability results. Consequently, we focus on
this restrictive version here. 
\end{remark}

We now show how to encode bounded model checking of
$\lrf$-represented hybrid systems using $\lrf$-formulas. The encoding is mostly
standard bounded model checking, as pointed out in~\cite{} already. However,
when the invariant of a mode is nontrivial, we need to make sure that a
trajectory satisfy the invariant throughout the continuous flow in the mode.
This requires nested quantifiers, which do not occur in other verification
domains, and has not been observed previously. We will consider systems with
trivial invariant conditions first, and then handle the general case.

Throughout the following two definitions, let $H = \langle X, Q, \flow,
\jump,\init\rangle$ be an $n$-dimensional $\lrf$-represented hybrid system with
$|Q|=m$, and $\unsafe$ an $\lrf$-formula that encodes a subset $U\subseteq
X\times Q$. Let $k\in \mathbb{N}$ and $M\in \mathbb{R}$ be the bounds on steps
and time respectively. Recall that $q_0\in Q$ always denotes the starting mode. 

\begin{definition}[$\reach^{k,M}(H,U)$, invariant-free case]
Let $H$ be invariant-free. Then $(k,M)$-reachability encoding of $H$ and $U$ is
defined as:
\begin{eqnarray*}
\reach^{k,M}(H,U) &:=&\exists^X \vec x_0 \exists^X\vec x_0^t\cdots \exists^X\vec
x_k\exists^X \vec x_k^t \exists^{[0,M]}t_0\cdots \exists^{[0,M]}t_k\\
& &\Big(\ \init_{q_0}(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0^t, t_0)\\
& &\wedge 
\bigvee_{i=0}^{k-1}\Big( \bigvee_{q, q'\in Q} \Big(\jump_{q\rightarrow q'}(\vec
x_i^t, \vec x_{i+1})\wedge \flow_{q'}(\vec x_{i+1}, \vec
x_{i+1}^t, t_{i+1})\Big)\Big)\\
& &\wedge\ \unsafe(\vec x_{k}^t)\Big). 
\end{eqnarray*}
\end{definition}

{\bf explain some.} This encoding is straightforward. Starting from intuitive:
$\reach_{H,q'}^k(\vec x_k^t)$ defines the statesthat $H$ can reach, if after $k$
steps of discrete changes it is in mode $q'$.
From there, if $H$ makes a $\jump$ from mode $q'$ to $q$, then the states have
the make a discrete change following $\jump_{q'\rightarrow q}(\vec x_k^t, \vec
x_{k+1})$. As last, in mode $q'$, any state $\vec x_{k+1}^t$ that $H$ can reach
should satisfy the $\flow$ conditions $\flow_q(\vec x_{k+1}^t, \vec x_{k+1}, t)$
in mode $q$. Note that after each discrete jump, a new time variable $t_k$ is
introduced and independent from the previous ones.
\begin{remark}
Note that the encoding in~\cite{} is recursive and exponential in size. Here it
is quadratic in the $\lrf$-description of a system, and it follows standard
bounded model checking. 
\end{remark}
Next, we define the encoding for general hybrid systems with nontrivial
invariants. 
\begin{remark}
{\bf [todo]} We need to be careful about nondeterminism here. 
\end{remark}
\begin{definition}[$\reach^{k,M}(H,U)$, general case]
Let $H$ be invariant-free. Then $(k,M)$-reachability encoding of $H$ and $U$ is
defined as:
\begin{eqnarray*}
\reach^{k,M}(H,U) &:=&\exists^X \vec x_0 \exists^X\vec x_0^t\cdots \exists^X\vec
x_k\exists^X \vec x_k^t \exists^{[0,M]}t_0\cdots \exists^{[0,M]}t_k\\
& &\Big(\ \init_{q_0}(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0^t,
t_0)\\
& &\wedge \forall^{[0,t_0]}t\forall^X\vec x\;(\flow_{q_0}(\vec x_0, \vec x,
t)\rightarrow \inv_{q_0}(\vec x)) \\
& &\wedge 
\bigvee_{i=0}^{k-1}\Big( \bigvee_{q, q'\in Q} \Big(\jump_{q\rightarrow q'}(\vec
x_i^t, \vec x_{i+1})\wedge \flow_{q'}(\vec x_{i+1}, \vec
x_{i+1}^t, t_{i+1})\\
& &\wedge \forall^{[0,t_0]}t\forall^X\vec x\;(\flow_{q'}(\vec x_{i+1}, \vec x,
t)\rightarrow \inv_{q_0}(\vec x)) )\Big)\Big)\\
& &\wedge\ \unsafe(\vec x_{k}^t)\Big). 
\end{eqnarray*}
\end{definition}

\begin{remark}[{\bf TODO}]
The restriction on invariant can be relaxed. usually there is only a big
invariant.
\end{remark}
We have explained the intuition behind the encoding of $\reach^{k,M}(H,U)$. A
formal statement of correctness is as follows. The proof is in \cite{}. 
\begin{proposition}
$H$ reaches $U$ in $k$ steps of discrete jumps with time duration
less than $M$ for each state, if and only if, $\reach^{k,M}(H,U)$ is true.
\end{proposition}

\subsection{Perturbations on Hybrid Automata}
We now define perturbations on hybrid systems.
\begin{definition}[Perturbations on Hybrid Automata]
Let $\delta\in\mathbb{Q}^+\cup\{0\}$. 
$$H = \langle X, Q, \flow, \jump, \inv, \init\rangle$$
is an $\lrf$-represented hybrid automaton. We define the {\em
$\delta$-weakening} of $H$ as
$$H^{\delta} = \langle X, Q, \flow^{\delta}, \jump^{\delta}, \inv^{\delta},
\init^{\delta}\rangle.$$
\end{definition}
\begin{proposition} We always have $\llbracket H\rrbracket\subseteq \llbracket
H^{\delta}\rrbracket.$
\end{proposition}
\begin{proof}
Let $\xi\in \llbracket H\rrbracket$ be any trajectory of $H$. Following
Definition~\ref{variants}, for any $\lrf$ sentence $\varphi$, we have 
$\varphi\rightarrow\varphi^{\delta}$. Now since
$\xi$ satisfies the conditions in Definition~\ref{trajec}, after replacing each
predicate in the definition by their $\delta$-weakenings, $\xi\in
\llbracket H^{\delta}\rrbracket$.
\end{proof}
\begin{remark}
Note that we only need to define overapproximations of the reachable states
which is used for verification purposes. It is conceivable that for other tasks,
strengthening will be needed (for instance for synthesizing parameters). 
\end{remark}

\begin{remark}
$H^{\delta}$ approximates $H$ {\em syntactically}. Semantically, it can be
tricky to quantify the effect of $\delta$. If we are dealing with a continuous
system, the Hausdorff distance between $\llbracket
H^{\delta}\rrbracket$ and $\llbracket H\rrbracket$ is continuous in
$\delta$. But for hybrid trajectories, relaxing the guards in a system can
generate very different trajectory sets. the syntactic
definition avoids such complications. 
\end{remark}

\subsection{Solving Bounded $\delta$-Reachability}

We now bridge the results between the $\delta$-decision problems and bounded
reachability checking. 


\begin{definition}[$\delta$-Reachability]
Let $H = \langle X, Q, \flow, \jump,\init\rangle$ be an
$n$-dimensional $\lrf$-represented hybrid system, and $\unsafe$ an
$\lrf$-formula that encodes a subset $U\subseteq X\times Q$. As is the case for
hybrid systems, we write $U^{\delta}$ to denote the interpretation of
$\unsafe^{\delta}$.  The $\delta$-reachability asks for one of the
following decisions:
\begin{itemize}
\item $\safe$: $H$ does not reach $U$. 
\item $\delta$-$\unsafe$: $H^{\delta}$ reaches $U^{\delta}$.
\end{itemize}
When the two cases overlap, either answer can be returned.
\end{definition}

\begin{lemma}\label{bmclemma}
Let $H$ be a hybrid automaton, $\unsafe$ a subset of its state space, and
$n\in\mathbb{N}$. We have:
\begin{itemize}
\item If $(\reach^n_{H,\unsafe})^{\delta}$ is true, then $H^{\delta}$ is unsafe.
\item If $\reach^n_{H,\unsafe}$ is false, then $H$ is safe up to $n$.
\end{itemize}
\end{lemma}

\begin{proposition}\label{equiv-delta}
$(\reach_{H,q}^n(\vec a))^{\delta}$ iff there is a trajectory $\xi\in
\llbracket H^{\delta}\rrbracket$ such that $\xi(n, t) = \vec a$ and
$\sigma_{\xi}(n) = q$.
\end{proposition}

\begin{theorem}
Let $\mathcal{F}$ be a set of computable functions. There exists an algorithm
such that, for any given $\lrf$-representable $H$ and an unsafe region
$\unsafe$, and a time bound $T$, decide the bounded $\delta$-reachability
problem for $H$.
\end{theorem}
It is clear that all we need is a $\delta$-complete decision procedure to solve
the bounded $\delta$-reachability problems. We say a bounded model checking
algorithm is $\delta$-complete, if it solves the $\delta$-reachability problem
correctly. It is clear that Algorithm \ref{delta-bmc} is $\delta$-complete if it
uses a $\delta$-complete decision procedure.


\begin{algorithm}\caption{$\delta$-Complete Bounded Model
Checking}\label{delta-bmc}

\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{An $\lrf$-represented hybrid automaton $\varphi = \langle X, Q, \flow,
\jump, \inv, \init\rangle$, time bound $T\in \mathbb{R}$, depth $n$}
\Output{Safe or $\delta$-Unsafe}
\BlankLine
$\reach_{H}(0,q_0,\vec x_0') \leftarrow \exists^X \vec
x_0\exists^{[0,T]}t_0\Big( \init_{q_0}(\vec x_0)\wedge \flow_{q_0}(\vec x_0',
\vec x_0, t_0)\Big)$\\
$k\leftarrow 0$\\
\While{$k<n$}
{
$\reach_{H}(k+1, q, \vec x_{k+1}') \leftarrow \exists^X\vec x_k'\exists^X
x_{k+1}\exists^{[0,T]}t_{k+1} \bigvee_{q\in Q}\Big(\reach_{H}(k, q, \vec
x_k')\wedge \flow(\vec x_k', \vec x_k, t_k)\wedge \forall^X \vec
x\forall^{[0,t_k]} t (\flow(\vec x, \vec x_k', t)\rightarrow \inv(\vec
x))\Big)$\\
$k\leftarrow k+1$
}
$\reach_{H,U} \leftarrow \exists \vec x(\reach_{H}(n, q, \vec x)\wedge
\unsafe(\vec x))$
\\
\eIf{$\reach_{H,U}$ is {\sf $\delta$-true}}
{$H$ is {\sf $\delta$-unsafe}}
{$H$ is {\sf safe} up to depth $n$ within time bound $T$}
\end{algorithm}


\subsection{Complexity Results}
We have reduced the bounded $\delta$-reachability problems to the decision
problems of $\lrf$-sentences. Thus, we can obtain the following complexity
results of the reachability problems.
\begin{theorem}
Suppose all the functions in the descriptionof $H$ is in Type 2 complexity class
$\mathsf{C}$. Then deciding the bounded $\delta$-Reach problem of Depth $n$, in
time bounded by $T$, for an invariant-free $H$ is in $\np^{\mathsf{C}}$, and the
problem for $H$ with invariant is in $\Sigma_2^{\mathsf{C}}$.
\end{theorem}

\begin{proof}
Note that the formula $\reach_{H,\unsafe}$  is exponential in the size of the
description of $H$. However, we can nondeterministically select a sequence of
$n$ modes, and check if reachability can be witnessed.

(i) For an invariant-free $H$, the formula  encoding one possible sequence of
$n$ steps of mode change is of the form:
\begin{eqnarray*}
& &\exists \vec x_0 \exists \vec x_0'\exists t_0\cdots \exists \vec
x_{n-1}\exists\vec x_{n-1}'\exists t_{n-1}\\
& &\Big(\init(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0', t_0)\wedge
\jump_{q_0\rightarrow q_1}(\vec x_0', \vec x_1)\wedge \cdots\\
& &\wedge \flow_{q_{n-1}}(\vec x_{n-1}, \vec x_{n-1}', t_{n-1}) \wedge
\unsafe(\vec x_{n-1}')\Big)
\end{eqnarray*}
where $q_1,...,q_{n-1}$ are random modes in $Q$ ($q_0$ is always the initial
one). This formula is polynomial in $H$, $n$, $T$. Thus, we can use the
nondeterministic machine to randomly first select such a formula in polynomial
time, and then $\delta$-decide its truth value, using the $\mathsf{C}$ oracle.
In all, the computation can be performed by a nondeterministic machine with a
$\mathsf{C}$-oracle in polynomial time. Thus, the $\delta$-reachability problem
is in $\mathsf{NP^C}$, following . On the other hand, any of the predicate, for
instance $\init(\vec x_0)$, is allowed to be an arbitrary quantifier-free
$\lrf$-formula. Thus it can encode any propositional logic formula as needed in
Corollary~\ref{Completeness}.

(ii) For a general $H$, the formula encoding one possible sequence of $n$ steps
of mode change is of the form:
\begin{eqnarray*}
& &\exists \vec x_0 \exists \vec x_0'\exists t_0\cdots \exists \vec
x_{n-1}\exists\vec x_{n-1}'\exists t_{n-1} \forall \vec x
\forall^{[0,t_0]}t_0'\cdots \forall^{[0,t_{n-1}]}t_{n-1}'\\
& &\Big(\init(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0', t_0)\wedge
\jump_{q_0\rightarrow q_1}(\vec x_0', \vec x_1)\\
& &\wedge (\flow_{q_0}(\vec x, \vec x_0, t_0')\rightarrow \inv_{q_0}(\vec
x))\wedge \cdots\\
& &\wedge\jump_{q_{n-2}\rightarrow q_{n-1}}(\vec x_{n-2}', \vec x_{n-1}) \wedge
\flow_{q_{n-1}}(\vec x_{n-1}, \vec x_{n-1}', t_{n-1})\\
& &\wedge (\flow_{q_{n-1}}(\vec x, \vec x_{n-1}, t_{n-1}')\rightarrow
\inv_q(\vec x))\\
& &\wedge \unsafe(\vec x_{n-1}')\Big)
\end{eqnarray*}
where $q_1,...,q_{n-1}$ are random modes in $Q$. Using a nondeterministic
Turing machine, such a formula is first selected in polynomial time, and its
truth value is $\delta$-decided as a $\Sigma_2$-sentence. Thus similarly as the
invariant-free case, it follows from Theorem~\ref{compmain} and
Corollary~\ref{Completeness} that the $\delta$-reachability problem is
$\mathsf{\Sigma_2^C}$-complete.
\end{proof}

\begin{remark}
The input parameters of the $\delta$-reachability problem are: the depth $n$,
the time bound $T$, the length of the $\lrf$-description of $H$, and the error
bound $\delta$.
\end{remark}


\section{Related Work}\label{discuss}
Formal work along this line started in the work~\cite{}.
Franzle defined a notion of noise in hybrid systems, and proved that problems
with polynomial maps are solvable in a compact space. Raschan later generalizes
this result in \cite{} and obtained more positive result
(Quasi-semidecidablity). However, results like this has been very sensitive to
the definition of noise or approximations. For instance, in \cite{} it is shown
that other definitions of noise and robustness still leads to undecidability.
These results are in general theoretical in nature and does not lend themselves
to practical solving techniques. {\bf More papers on nonlinear tools ()}



\section{Experiments}\label{experiments}

We implemented a bounded model checking {\tt dReach} using the
techniques shown above. The tool relies on our SMT solver {\tt dReal}~\cite{},
which provides $\delta$-decisions on $\lrf$-formulas. The tool is
open-source. The latest version and all the benchmarks are at {\tt
http://cmacs.cs.cmu.edu/dReach}.We describe more details of our tool in~\cite{}.
All the experiments are ran on a {\bf what} machine. 

Here we list results on several nonlinear hybrid models that we believe are
beyond the scope of existing tools.
The {\sf Cardiac Cell Model}... The {\sf Power Grid Model}... The {\sf Legged
Robotics Model}... All of them contain nonlinear ODEs and frequent use of
trignometric and exponential functions, and model realistic systems in practice.
More details of the models are in the Appendix. 

The columns in the table shows the following data, from left to right. {\sf
depth} is the unwinded depth of the model for bounded model checking. Again, we
only count the number of discrete mode switching, which is usually small in
practice. {\sf $\delta$} is error bound we set, which in this case is the size
of the interval on the output solution. {\sf \#vars} is the number of real
variables and {\sf \#atoms} is the number of atomic
formulas in the formula. {\sf \#ODE} shows the number of differential equations
involved. \#{\sf icp-solve} \#{ode-solve} are the number of ICP solving steps (a
pair of pruning and branching steps) and ODE solving steps, respectively.
\#{\sf conflict} is the number of conflict observed (and also backtracking) in
the high-level DPLL(T) framework. {result} is the final answer of the tool. {\sf
time} and {\sf mem} show that CPU time and memory cost. 

\input{experiments_table.tex}

\section{Conclusion}


We believe the notion of $\delta$-complete methods lead to a new framework that
resolves other problems as well, which can be of considerable theoretical
interest. Currently the precise versions of these problems are open, but we
believe in a $\delta$-perturbed picture they all allow definite answers. We
will show discuss these directions for short and leave some conjectures here.





\bibliographystyle{abbrv}
\bibliography{tau}

\newpage
\section*{Appendix}
\end{document}