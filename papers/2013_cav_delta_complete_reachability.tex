\documentclass[envcountsect]{llncs}

\usepackage{stmaryrd,amsmath,amssymb,newlfont,graphicx,caption,verbatim}
\usepackage[ruled,lined,boxed,commentsnumbered,linesnumbered]{algorithm2e}

\newtheorem{notation}[theorem]{Notation}

\newcommand{\dom}{\mathrm{dom}}
\newcommand{\len}{\mathit{len}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\flow}{\mathsf{flow}}
\newcommand{\jump}{\mathsf{jump}}
\newcommand{\inv}{\mathsf{inv}}
\newcommand{\init}{\mathsf{init}}
\newcommand{\guard}{\mathsf{guard}}
\newcommand{\reset}{\mathsf{reset}}
\newcommand{\reach}{\mathsf{Reach}}
\newcommand{\unsafe}{\mathsf{unsafe}}
\newcommand{\safe}{\mathsf{safe}}
\newcommand{\p}{\mathsf{P}}
\newcommand{\np}{\mathsf{NP}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\lrf}{\mathcal{L}_{\mathbb{R}_{\mathcal{F}}}}


\setlength{\textwidth}{5.1in}
%\setlength{\textheight}{8.2in}
%\setlength{\topmargin}{0in}
\setlength{\oddsidemargin}{.7in}
\setlength{\evensidemargin}{.7in}

\title{Bounded $\delta$-Reachability for Hybrid Systems}
\author{Sicun Gao \and Soonho Kong \and Edmund M. Clarke}
\institute{Carnegie Mellon University, Pittsburgh, PA 15213}

\begin{document}
\maketitle

\begin{abstract}
We study the bounded ``$\delta$-reachability'' problem for hybrid systems. Let
$\delta$ denote a desirable error bound, we say a hybrid system $H$ can
$\delta$-reach a set $U$ if under some $\delta$-perturbation, $H^{\delta}$
reaches $U^{\delta}$, which are formally defined on their representations given
by first-order formulas over the reals. We show that the bounded
$\delta$-reachability problem for a wide range of nonlinear hybrid systems can
be solved, using our recent results of bounded $\delta$-decidability of
first-order theories over the reals with arbitrary computable real functions
(polynomials, transcendental functions, nonlinear ODEs, etc.). Following this
new framework, practical verification
tools can be developed using decision procedures over the reals that exploit
the full power of numerical algorithms in a formal way. We show promising
experimental results on nonlinear hybrid systems. 

\end{abstract}

\section{Introduction}

Hybrid systems model the tight coupling of discrete and continuous components
in cyber-physical systems. Formal verification of hybrid systems is
important and challenging. It is well known that safety verification
problems for hybrid systems with very simple dynamics are
undecidable~\cite{DBLP:journals/tse/AlurHH96,DBLP:journals/jcss/HenzingerKPV98,
DBLP:journals/tcs/Bournez99}. In practice, systems
with constant-rate dynamics
and some systems with linear dynamics (but simple discrete control structures)
can be handled
algorithmically~\cite{DBLP:journals/tse/AlurHH96,lpw:sttt97,DBLP:conf/hybrid/ChutinanK99,DBLP:conf/hybrid/AsarinDMB00,DBLP:conf/cav/AsarinDM02,DBLP:conf/hybrid/GirardGM06,DBLP:conf/cav/GuernicG09}; proof-theoretic
approaches can verify some nonlinear systems after manual analysis~\cite{DBLP:journals/logcom/Platzer10,DBLP:conf/hybrid/Sankaranarayanan10}.
However, the gap between existing technology
and the goal of automatic verification of realistic hybrid systems of a
reasonable scale is still wide.

A bottleneck problem for hybrid systems verification is to determine the truth
value of first-order sentences over the reals with nonlinear real functions,
which is well-known to be a very hard or undecidable problem~\cite{}. Recently
we have developed a new framework to study the ``$\delta$-decision'' problem
instead~\cite{}, asking for answers that may have one-sided $\delta$-bounded
errors. That is, given a first-order sentence $\varphi$, we ask whether
$\varphi$ is false, or some $\delta$-relaxation of $\varphi$ is true, which is
defined as a slight syntactic variation of $\varphi$. We proved the
$\delta$-decidabilty of bounded first-order sentences over the reals with
arbitrary computable real functions (as
defined in computable analysis~\cite{CAbook}, including polynomials,
transcendental functions, solutions of Lipschitz-continuous ODEs, etc.).
This framework leads to the development of numerically-driven decision
procedures that exploit the full power of efficient numerical algorithms in a
formal way, with promising performance~\cite{}.

In this paper, we show how to apply the $\delta$-decision framework to
hybrid system verification. We study the problem of bounded
$\delta$-reachability, which can be encoded as decision
problems over the reals, for a wide range of nonlinear hybrid systems. 

First of all, our study of first-order formulas with arbitrary computable real
functions equips us with a rich language for describing hybrid systems in
general. We define $\lrf$-representable hybrid systems, where $\mathcal{F}$ can
be any set of computable real functions. The classes of hybrid systems that have
been studied in the existing literature can all be easily defined by restricting
$\mathcal{F}$. We define the notion of perturbations on hybrid
systems as syntactic perturbations on their $\lrf$-representations, which
 will provide the key link to $\delta$-decidability results. 

Second, we define the $\delta$-reachability problem as a slight
relaxation of the standard reachability problem. Let $\delta\in \mathbb{Q}^+$ be
arbitrary. Give a hybrid system $H$ and a region $U$ of its state
space, both $\lrf$-represented, the $\delta$-reachability problem asks for
one of the following answers:
\begin{itemize}
 \item {\sf safe}: $H$ can not reach $U$.
 \item {\sf $\delta$-unsafe}: Under some $\delta$-perturbation, $H^{\delta}$ can
reach $U^{\delta}$. 
\end{itemize}
These answers are in fact not weaker than the precise ones for
verification purposes. When {\sf safe} is the answer, we know for certain
that $H$ does not reach the unsafe region; when {\sf $\delta$-unsafe} is the
answer, there exists some $\delta$-bounded perturbation in the
system that {\em would} render it unsafe. Note that the error-bound $\delta$ can
be chosen to be arbitrarily small, so that the {\sf$\delta$-unsafe} answer
discovers robustness problem in the system, which should be regarded as unsafe
indeed. We encode the checking of bounded $\delta$-reachability as
$\lrf$-sentences. As a consequence, we can prove that the bounded
$\delta$-reachability problem is decidable for arbitrary
$\lrf$-representable hybrid systems, with complexity bounds $\mathsf{NP^C}$
(trivial invariants) and $\mathsf{(\Sigma_2^P)^C}$ (general case) where
$\mathsf{C}$ is the complexity class that $\mathcal{F}$ lies in. Compared to the
 undecidability of standard bounded reachability of very simple hybrid systems,
the results lead to a new outlook for general hybrid system
verification. 

Third, the new framework directly leads to practical solving techniques. Using a
powerful decision procedure, we perform bounded model checking on nonlinear
hybrid systems that contain many transcendental
functions and nonlinear ODEs, and show the promising experimental results. 

The paper is organized as follows. First, we review the background framework of 
$\delta$-decisions for first-order formulas in Section~\ref{review},
and then define $\lrf$-representations of hybrid systems in
Section~\ref{language}. We study the bounded $\delta$-reachability problem in
Section~\ref{main}, proving decidability and complexity bounds, through their
encodings as $\lrf$-formulas. We discuss related work in detail in
Section~\ref{discuss}. We show experimental results of our tool {\tt dReach} on
nonlinear hybrid systems in Section~\ref{experiments}. 

\section{A Brief Review of $\delta$-Decidability over the Reals}\label{review}

We first briefly review our framework of $\delta$-decision problems for
first-order sentences over the reals with computable real functions. More
details can be found in~\cite{}. 

To formalize computations over the reals, we first need to encode the real
numbers, as infinite strings. We can then model computations of real functions
with machines that can use infinite strings as input and output. That is, a real
function is computable if there exists a machine that computes, using oracles
that encode the arguments of the function, the values of the function to an
arbitrary precision. The following formal definitions are standard in 
computable
analysis~\cite{CAbook}.
\begin{definition}[Encoding Real Numbers]
A {\em name} of a real number $a\in \mathbb{R}$ is a function
$\mathcal{\gamma}_a: \mathbb{N}\rightarrow \mathbb{Q}$ satisfying that for all
$i\in \mathbb{N}$, $|\gamma_a(i) - a|<2^{-i}.$ For $\vec a\in \mathbb{R}^n$,
$\gamma_{\vec a}(i) = \langle \gamma_{a_1}(i), ..., \gamma_{a_n}(i)\rangle$, and
$\Gamma(\vec a) = \{\gamma: \gamma\mbox{ is a name of }\vec a\}$.
\end{definition}
\begin{definition}[Computable Real Functions] We say
$f:\subseteq\mathbb{R}^n\rightarrow \mathbb{R}$ is computable, if there exists
an oracle Turing machine $\mathcal{M}_f$ as follows. Let $\vec a\in
\dom(f)$ be any argument of $f$ and $\gamma(\vec a)$
any name of $\vec a$. On any input $i\in \mathbb{N}$,
$\mathcal{M}_f^{\gamma(\vec a)}(i)$ uses $\gamma(\vec a)$ as an oracle, and
computes a $2^{-i}$-approximation to $f(\vec a)$.
\end{definition}
Most common continuous real functions are computable, such as addition,
multiplication,  absolute value, $\min$, $\max$, $\exp$, $\sin$ and solutions of
Lipschitz-continuous ordinary differential equations. Compositions
of computable functions are computable.

We consider first-order formulas with computable real functions interpreted
over the reals. We write $\mathcal{F}$ to denote an arbitrary collection of
symbols representing computable functions over $\mathbb{R}^n$ for various
$n$. Constants are seen as 0-ary functions. We always assume that
$\mathcal{F}$ contains at least $0$, unary negation, addition, and
the absolute value.  Let $\mathcal{L_{\mathcal{F}}}$ be the signature $\langle
\mathcal{F}, >\rangle$. $\lrf$-formulas are evaluated in the standard way over
the corresponding structure $\mathbb{R}_{\mathcal{F}}= \langle \mathbb{R},
\mathcal{F}, >\rangle$.  It is
not hard to see that we only need to use atomic formulas of the form
$t(x_1,...,x_n)>0$ or $t(x_1,...,x_n)\geq 0$, where $t(x_1,...,x_n)$ are built
up from functions in $\mathcal{F}$. To avoid extra preprocessing of formulas, we
give an explicit definition of $\lrf$-formulas as follows.
\begin{definition}[$\lrf$-Formulas]
Let $\mathcal{F}$ be a collection of Type 2 functions, which contains at least
$0$, unary negation -, addition $+$, and absolute value $|\cdot|$. We define:
\begin{align*}
t& := x \; | \; f(t(\vec x)), \mbox{ where }f\in \mathcal{F}\mbox{, possibly
constant};\\
\varphi& := t(\vec x)> 0 \; | \; t(\vec x)\geq 0 \; | \; \varphi\wedge\varphi
\; | \; \varphi\vee\varphi \; | \; \exists x_i\varphi \; |\; \forall x_i\varphi.
\end{align*}
In this setting $\neg\varphi$ is regarded as an inductively defined operation
which replaces atomic formulas $t>0$ with $-t\geq 0$, atomic formulas $t\geq 0$
with $-t>0$, switches $\wedge$ and $\vee$, and switches $\forall$ and $\exists$.
Implication $\varphi_1\rightarrow\varphi_2$ is defined as
$\neg\varphi_1\vee\varphi_2$.
\end{definition}
\begin{definition}[Bounded Quantifiers]
We define
\begin{align*}
\exists^{[u,v]}x.\varphi &=_{df}\exists x. ( u \leq x \land x \leq v \wedge
\varphi),\\
\forall^{[u,v]}x.\varphi &=_{df} \forall x. ( (u \leq x \land x \leq v)
\rightarrow \varphi),
\end{align*}
where $u$ and $v$ denote $\lrf$ terms whose variables only
contain free variables in $\varphi$, excluding $x$. It is easy to check that
$\exists^{[u,v]}x. \varphi \leftrightarrow \neg \forall^{[u,v]}x. \neg\varphi$.
\end{definition}
We say a sentence is bounded if it only involves bounded quantifiers.
\begin{definition}[Bounded $\lrf$-Sentences]
A {\em bounded $\lrf$-sentence} is
$$Q_1^{[u_1,v_1]}x_1\cdots Q_n^{[u_n,v_n]}x_n\;\psi(x_1,...,x_n).$$
$Q_i^{[u_i,v_i]}$s are bounded quantifiers, and $\psi(x_1,...,x_n)$ is a
quantifier-free $\lrf$-formula.
\end{definition}
We write $\psi(x_1,...,x_n)$ as $\psi[t_1(\vec
x)>0,...,t_k(\vec x)>0; t_{k+1}(\vec x)\geq 0,...,t_m(\vec
x)\geq 0]$ to emphasize that $\psi(\vec x)$ is a Boolean
combination of the atomic formulas shown. 
\begin{definition}[$\delta$-Variants]\label{variants}
Let $\delta\in \mathbb{Q}^+\cup\{0\}$, and $\varphi$ an
$\lrf$-formula of the form
$$\varphi: \ Q_1^{I_1}x_1\cdots Q_n^{I_n}x_n\;\psi[t_i(\vec x, \vec y)>0;
t_j(\vec x, \vec
y)\geq 0],$$ where $i\in\{1,...k\}$ and $j\in\{k+1,...,m\}$. The {\em
$\delta$-weakening} $\varphi^{-\delta}$ of $\varphi$ is
defined as the result of replacing each atom $t_i > 0$ by $t_i >
-\delta$ and $t_j \geq 0$ by $t_j \geq -\delta$. That is, 
$$\varphi^{-\delta}:\ Q_1^{I_1}x_1\cdots Q_n^{I_n}x_n\;\psi[t_i(\vec x, \vec
y)>-\delta; t_j(\vec x,
\vec y)\geq -\delta].$$
\end{definition}

We then have the following main decidability result. 
\begin{theorem}[$\delta$-Decidability] Let $\delta\in\mathbb{Q}^+$ be
arbitrary. There is an algorithm which, given any bounded $\varphi$,
correctly returns one of the following two answers:
\begin{itemize}
\item ``$\delta$-$\mathsf{True}$'': $\varphi^{-\delta}$ is true.
\item ``$\mathsf{False}$'': $\varphi$ is false.
\end{itemize}
Note when the two cases overlap, either answer is correct. 
\end{theorem}
We call this new decision problem the $\delta$-decision problem for
$\lrf$-sentences. We proved the following complexity results. 
\begin{theorem}[Complexity]\label{compmain}
Let $\mathcal{F}$ be a class of computable functions. Let $S$ be a class of
$\lrf$-sentences, such that for any $\varphi$ in $S$, the
terms in $\varphi$ are computable in complexity class $\mathsf{C}$ where
$\mathsf{P\subseteq \mathsf{C}\subseteq \mathsf{PSPACE}}$.
Then, for any $\delta\in \mathbb{Q}^+$, the $\delta$-decision problem for
bounded $\Sigma_n$-sentences in $S$ is in $\mathsf{(\Sigma_n^P)^C}$.
\end{theorem}

\section{Hybrid Systems with $\lrf$-Representations}\label{language}

We give a precise syntax and semantics of hybrid systems using
$\lrf$-formulas and their interpretations, and then define the notion of
$\delta$-perturbations on them. 

\subsection{Basic Definitions}
A standard definition of general hybrid systems is as follows~\cite{}. 
\begin{definition}[Hybrid Automata]\label{auto-def}
An $n$-dimensional hybrid automaton is a tuple $H   = \langle X, Q, \flow,
\guard, \reset, \inv, \init\rangle$ that contains the following elements. 
\paragraph{\bf State Space.} $X\subseteq \mathbb{R}^n$ specifies the range of
the {\em continuous variables}  $\vec x$ of the system. $Q=\{q_0,...,q_m\}$ is
a finite set of discrete {\em control modes}.

\paragraph{\bf Continuous Components.} $\flow \subseteq Q\times
X\times \R \times X$ specifies the {\em continuous dynamics}
for each mode: $(q, \vec a_0, t, \vec a_t)\in \flow$, if in mode $q$,
there is a continuous flow from $\vec x =\vec a_0$ to $\vec x = \vec a_t$
after a time duration of $t$.

The $\flow$ predicate is usually defined either as explicit mappings from
$\vec a_0$ and $t$ to $\vec a_t$,  or as solutions of systems of differential
equations/inclusions that specify the derivative of $\vec x$ over time, with
initial conditions given by $\vec x_0$.

\paragraph{\bf Discrete Components.} $\jump\subseteq Q\times
X\times Q\times X$ specifies the {\em jump conditions}
between two modes: $(q,q',\vec a,\vec a')\in \jump$ if in mode $q$,
when the continuous variables are of value $\vec x = \vec a$, the automaton may
switch to mode $q'$, and set the continuous variables to $\vec x = \vec
a'$.  

\paragraph{\bf Initial and Invariant Conditions.} $\inv \subseteq Q\times X$
specifies the {\em invariant conditions} for
the system to stay in a control mode: $(q,\vec a)\in \inv$, if when the
automaton is in mode $q$, $\vec x = \vec a$ is a possible value for its
continuous variables.

$\init \subseteq Q\times X$ specifies the set of {\em
initial configurations} of the system: $(q, \vec a)\in \init$, if the
automaton can start from an initial configuration $\vec x = \vec a$ in mode
$q$.\} Without loss of generality, we always set $q=q_0$ in $\init$. (When there
are multiple initial modes, an additional mode can be
added to act as the only initial mode.)
\end{definition}
According to the definition, a hybrid automaton can be nondeterministic in
various ways.  The $\flow$ and $\jump$ conditions are not
restricted to single-valued functions.
\begin{remark}[$\jump$ vs $\inv$] The jump conditions specify when an automaton
{\em may}  switch to another mode. The invariants (when violated) specify when
an automaton {\em must} switch to another mode. All may-jumps can
be reduced to nondeterministic must-jumps. However, they will give rise to
different logical structures. See Section~\ref{encode}. 
\end{remark}
\begin{definition}\index{Invariant-free
Hybrid Automata}
A hybrid automata $H = \langle X, Q, \flow, \jump, \inv, \init\rangle$ is
 {\em invariant-free} if $\inv = Q\times X$, and we say the invariant is {\em
trivial} in this case.
\end{definition}

\subsection{$\lrf$-Representations}

We now define logical representations of hybrid systems. It is a general
formal representation that can express almost any hybrid system that models
realistic systems. 

\begin{definition}[$\lrf$-Representations]\label{lrf-definition}
\index{$\lrf$-Representation}
Let $H$ be an $n$-dimensional hybrid automaton.  Let $\mathcal{F}$
be a set of real functions, and $\mathcal{L}_{\mathbb{R}_{\mathcal{F}}}$ the
corresponding first-order language. We say that $H$ has an
$\lrf$-representation, if for every $q,q'\in Q$, there exists  quantifier-free
$\lrf$-formulas $$\phi^q_{\flow}(\vec x, \vec x_0, t), \phi^{q\rightarrow
q'}_{\jump}(\vec x,
\vec x'), \phi^{q}_{\inv}(\vec x), \phi^q_{\init}(\vec x)$$
such that for all
$\vec a ,\vec a'\in \mathbb{R}^n$,
$t\in\mathbb{R}$:
\begin{itemize}
\item $\mathbb{R}\models \phi^q_{\flow}(\vec a, \vec a', t)$ iff $(q, \vec
a,
\vec a', t)\in \flow$.
\item $\mathbb{R}\models \phi^{q\rightarrow q'}_{\jump}(\vec a, \vec a')$ iff
$(q, q', \vec a, \vec a')\in \jump$.
\item $\mathbb{R}\models \phi^q_{\inv}(\vec a)$ iff $(q, \vec a)\in \inv.$
\item $\mathbb{R}\models \phi^q_{\init}(\vec a)$ iff $q = q_0$ and $\vec a\in
\init_{q_0}$.
\end{itemize}
We can write $H = \langle X, Q, \phi_{\flow}, \phi_{\jump}, \phi_{\inv},
\phi_{\init}\rangle$ to emphasize that $H$ is represented in this way. But for
notational simplicity, when
the context is clear, we simply write $\flow, \jump, \inv, \init$ to denote
these logic formulas.
\end{definition}

\begin{remark}
We have not restricted the structures of the formulas defining each
predicate. This makes the definition more general
than necessary. For instance, the flow should be a continuous mapping from $\vec
x_0$ and $t$ to $\vec x_t$, and thus $\phi^q_{\flow}(\vec a,
\vec a_0, t)$ is usually a conjunction of equations of the form $\vec x_t =
f(\vec x_0, t)$, instead of arbitrary formulas. Different classes of hybrid
systems can be defined by refining this definition.
\end{remark}

\begin{definition}[Computable Representation]
We say a hybrid automaton $H$ has a {\em computable representation}, if $H$ has
an $\lrf$-representation, $\mathcal{F}$ is a set of computable functions.
\end{definition}
\begin{remark}
$\mathcal{F}$ can contain arbitrary computable functions, such as
polynomials, transcendental functions, Lipschitz-continuous ODEs and many PDEs.
In fact, since hybrid systems of practical interest should only involve
functions that at least allow numerical simulation, they should all have
computable representations. From now on we will only consider hybrid automata
that have computable representations. 

\end{remark}

We now formally specify the semantics. Combining continuous and discrete
behaviors, the trajectories of hybrid systems are {\em piecewise continuous}.
This motivates a two-dimensional structure of time~\cite{}, with which we can
keep track of both the discrete changes and the duration of each continuous
flow.
\begin{definition}[Hybrid time domain]
A {\em hybrid time domain} $T$ is a subset of
 $\mathbb{N}\times \mathbb{R}$ of the form
$T_m=\{(i, t): i<m \mbox{ and } t\in [t_i, t_i']\mbox{ or }[t_i, +\infty)\},$
where $m\in \mathbb{N}\cup\{+\infty\}$, $\{t_i\}_{i=0}^m$ is an
increasing sequence in $\mathbb{R}^+$, $t_0= 0$, and $t_i'=t_{i+1}$.
\end{definition}
We write the set of all hybrid time domains as $\mathbb{H}$.
\begin{definition}[Hybrid Trajectories]
Let $X\subseteq\mathbb{R}^n$ be an Euclidean space and $T_m$ a hybrid
time domain. A {\em hybrid trajectory} is any continuous function $\xi: T_m
\rightarrow X.$
 \end{definition}
We write $\Xi_X$ to denote the set of all possible hybrid trajectories from
$\mathbb{H}$ to $X$.
 \begin{remark}
Note that the trajectories become continuous because of the discrete component
in $T$. More details of the topological structures are in the
Appendix. A two-dimensional time domain avoids ``break points'' on the
continuous dimension. At the discrete change points, $(i,t_i')$ and $(i+1,
t_{i+1})$ are distinguished by the first coordinate, and the time intervals for
each $i$ can
always include both endpoints.
\end{remark}

We can now define trajectories of a given hybrid automaton. The intuition behind
the following definition is straightforward. The labeling function
$\sigma_{\xi}^H(i)$ is used to map a step $i$ to the corresponding discrete mode
in $H$. In each mode, the system flows continuously following the dynamics
defined by $\flow(q, \vec x_0, t)$. Note that $(t-t_k)$ is the actual duration
in the $k$-th mode. When a switch between two modes is performed, it is required
that $\xi(k+1, t_{k+1})$ is updated from the exit value $\xi(k, t_k')$ in the
previous mode, following the jump conditions.

\begin{definition}[Trajectories of a Hybrid Automaton]\label{trajec}
Let $H$ be a hybrid automaton, and $\xi: T_m\rightarrow X$ a hybrid trajectory.
We say that $\xi$ is {\em a trajectory of $H$ of discrete depth $m$}, if there
exists a {\em labeling function} $\sigma^H_{\xi}: \mathbb{N}\rightarrow Q$ such
that:
\begin{itemize}
\item $\sigma^H_{\xi}(0) = q_0$ and
$\mathbb{R}_{\mathcal{F}}\models \init_{q_0}(\xi(0,0))$;
\item For any $(i, t)\in T_m$,
$\mathbb{R}_{\mathcal{F}}\models \inv_{\sigma^H_{\xi}(i)} (\xi(i,t))$;
\item When $i=0$,
$$\mathbb{R}_{\mathcal{F}}\models\flow_{q_0}(\xi(0,0), \xi(0,t), t).$$
\item When $i = k+1$, where $0< k+1 <m$,
\begin{eqnarray*}
\mathbb{R}_{\mathcal{F}}&\models&\flow_{\sigma^H_{\xi}(k+1)}(\xi(k+1, t_{k+1}),
\xi(k+1, t), (t - t_{k+1}))\mbox{ and }\\
\mathbb{R}_{\mathcal{F}}&\models& \jump_{(\sigma^H(k)\rightarrow
\sigma^H(k+1))}(\xi(k, t_k'), \xi(k+1,t_{k+1})).
\end{eqnarray*}
\end{itemize}
\end{definition}
We write $\llbracket H\rrbracket$ to denote the set of all possible trajectories
of $H$.
\subsection{Perturbations on Hybrid Automata}
We now define perturbations on hybrid systems.
\begin{definition}[Perturbations on Hybrid Automata]
Let $\delta\in\mathbb{Q}^+\cup\{0\}$. 
$$H = \langle X, Q, \flow, \jump, \inv, \init\rangle$$
is an $\lrf$-represented hybrid automaton. We define the {\em
$\delta$-weakening} of $H$ as
$$H^{\delta} = \langle X, Q, \flow^{-\delta}, \jump^{-\delta}, \inv^{-\delta},
\init^{-\delta}\rangle.$$
\end{definition}
\begin{proposition} Let $\delta\in\mathbb{Q}^+\cup \{0\}$ and $H$ be given. We
always have $\llbracket H\rrbracket\subseteq \llbracket H^{\delta}\rrbracket.$
\end{proposition}
\begin{proof}
Let $\xi\in \llbracket H\rrbracket$ be any trajectory of $H$. Following
Definition~\ref{variants}, for any $\lrf$ sentence $\varphi$, we have 
$\varphi\rightarrow\varphi^{-\delta}$. Now since
$\xi$ satisfies the conditions in Definition~\ref{trajec}, after replacing each
predicate in the definition by their $\delta$-weakenings, $\xi\in
\llbracket H^{\delta}\rrbracket$.
\end{proof}
\begin{remark}
Note that we only need to define overapproximations of the reachable states
which is used for verification purposes. It is conceivable that for other tasks,
strengthening will be needed (for instance for synthesizing parameters). 
\end{remark}

\begin{remark}
$H^{\delta}$ approximates $H$ {\em syntactically}. Semantically, it can be
tricky to quantify the effect of $\delta$. If we are dealing with a continuous
system, the Hausdorff distance between $\llbracket
H^{\delta}\rrbracket$ and $\llbracket H\rrbracket$ is continuous in
$\delta$. But for hybrid trajectories, relaxing the guards in a system can
generate very different trajectory sets. the syntactic
definition avoids such complications. Some details are discussed in the
Appendix.
\end{remark}


\subsection{Reachability and Safety Verification}

The safety/reachability problem for hybrid systems can be stated formally as
follows. 
\begin{definition}[Reachability]\label{reachability}\index{Reachability}
Let $H$ be an $n$-dimensional hybrid automaton, and $U$ a subset of its state
space.  We say {\em $U$ is reachable by $H$}, if there exists $\xi\in\llbracket
H \rrbracket$ with its time domain $T$ and labeling function
$\sigma_{\xi}^H$, such that there exists $(i,t)\in T$ satisfying
$(\sigma^H_{\xi}(i), \xi(i,t))\in U.$ When we only ask whether a subset of the
Euclidean space is reachable, it means whether the region is reachable in any
discrete mode.
\end{definition}
In the seminal work of \cite{DBLP:conf/rex/AlurD91,DBLP:conf/hybrid/AlurCHH92},
it is already shown that the reachability problem for simple classes of hybrid
automata is already undecidable. In fact, clear boundaries of the decidable and
undecidable classes has been given~\cite{DBLP:journals/jcss/HenzingerKPV98}.
\begin{definition}[Linear Hybrid Automata]
Let $\mathcal{F} = \{+\}\cup \mathbb{Q}$ (the rational numbers are considered as
 0-ary functions). We say a hybrid automaton $H$ is a {\em linear hybrid
automaton} if it has an $\lrf$-representation.
\end{definition}

\begin{proposition}[Undecidability for
LHA~\cite{DBLP:conf/hybrid/AlurCHH92,}]
The bounded reachability problem for linear hybrid automata is undecidable.
\end{proposition}
It is standard in the existing literature that all the constants used in the
description of a hybrid automaton are rational, so that symbolic algorithms can
be used. We avoid such restrictions and allow any
computable signature $\mathcal{F}$, which means  any computable real numbers
can be used as constants in the description of hybrid automata. It is worth
noting that allowing arbitrary computable reals itself would already render the
reachability problem for even more trivial classes of hybrid automata
to be undecidable. Indeed, since the equality test $x=a$ is
undecidable~\cite{CAbook},
the question of whether a flow of $dx/dt = 1$ can reach some point $a$ is
undecidable already. (The decidablility of
timed automata~\cite{DBLP:conf/rex/AlurD91} require the use of rational
constants only. )

\section{Bounded $\delta$-Reachability}\label{main}

\subsection{Encoding Reachability}\label{encode}

In this section we show how to encode bounded model checking of
$\lrf$-represented hybrid systems using $\lrf$-formulas. It will be shown that
when we encode reachability for hybrid automata with nontrivial invariant
conditions, the logical formulas are more complex. We consider automata
with no invariant conditions first, and then handle the general case.
\vspace{-.4cm}
\subsubsection{Automata without Invariants} We define
the logic encoding inductively on the number of discrete transitions as
follows. Let $H$ be an invariant-free hybrid automaton $\langle X, Q, \flow,
\jump,\init\rangle$. We define the following formulas to encode the reachable
states of any bounded depth.
\paragraph{The Case of $0$ Transitions.} First, consider the reachable states of
$H$ in the initial mode, before making any discrete jump. In this case, the
system
evolves according to the flow of the initial state.

Recall that the initial mode is written as $q_0$, and $\flow_{q_0}(\vec x^t,
\vec x, t)$ means that in mode $q_0$, if the system starts the continuous flow
with $\vec x$ being the initial state of the continuous variables, then after a
time duration of $t$, the continuous variables reach the state $\vec x^t$. The
formula that encodes all the possible $\vec x_0^t$ that the system can
reach in the initial mode is:
$$\reach^0_{H,q_0} (\vec x_0^t):=\ \exists \vec x_0 \exists t_0\
\init_{q_0}(\vec
x_0)\wedge \flow_q(\vec x_0^t, \vec x_0, t_0)$$
For any $q\neq q_0$, $\reach^0_{H,q}$ is $\bot$.
We write the number of
discrete jumps in the subscripts, such as in $\vec
x_k$. The superscript $t$ as in $\vec x^t$ is not a variable: $\vec x^t$ denotes
the values of the continuous variables after some continuous flow.) Note that
$\vec x_0^t$ are the only free variables in the formula.

\paragraph{The Case of $k+1$ Transitions.} Next, consider the induction case in
which
the system makes a discrete jump from a previous mode. Assume that
$\reach^k_{H,q'}$ are defined for any $q'\in Q$. We have:
\begin{multline*}
\reach^{k+1}_{H,q}(\vec x_{k+1}^t):=  \exists \vec x_k^t\exists \vec
x_{k+1}\exists t_{k+1}\ \\
\bigvee_{q'\in Q} (\reach^k_{H,q'} (\vec x_k^t) \wedge \jump_{q'\rightarrow
q}(\vec x_k^t, \vec x_{k+1}) \wedge \flow_{q}(\vec x_{k+1}^t, \vec x_{k+1},
t_{k+1}))
\end{multline*}
This encoding is intuitive: $\reach_{H,q'}^k(\vec x_k^t)$ defines the states
that $H$ can reach, if after $k$ steps of discrete changes it is in mode $q'$.
From there, if $H$ makes a $\jump$ from mode $q'$ to $q$, then the states have
the make a discrete change following $\jump_{q'\rightarrow q}(\vec x_k^t, \vec
x_{k+1})$. As last, in mode $q'$, any state $\vec x_{k+1}^t$ that $H$ can reach
should satisfy the $\flow$ conditions $\flow_q(\vec x_{k+1}^t, \vec x_{k+1}, t)$
in mode $q$. Note that after each discrete jump, a new time variable $t_k$ is
introduced and independent from the previous ones.

In all, the set of all reachable states of the system, after making $n$
transitions from $q_0$ is encoded by:
$$\reach^n_{H}(\vec x) := \bigvee_{q'\in Q} \reach^n_{H,q'}(\vec x).$$
\begin{remark}
Recall the definition of discrete depth in Definition~\ref{trajec}: We only
count the number of discrete changes in the trajectories of a hybrid automaton.
\end{remark}
\begin{remark}
In $\reach_{q_0}^n(\vec x)$, the existential quantifiers are nested. It is
clear that they can be directly prenexed without changing the structure of the
formulas.
\end{remark}
It is not hard to see that the formula defined in this way correctly encodes
reachability. The formal proof is in the Appendix.
\begin{proposition}
Let $H$ be an invariant-free hybrid automaton. Then for any $\vec a\in
\mathbb{R}^n$, $\reach^n_q(\vec a)$ iff there exists a depth-$n$ trajectory
$\xi\in\llbracket H\rrbracket$ such that $\xi(n, t) = \vec a$ for some
$t\in\mathbb{R}$, and $\sigma_{\xi}(n) = q$ .
\end{proposition}

\begin{definition}[$\reach^n_{H,\unsafe}$] Let $H$ be an invariant-free hybrid
automaton. Let $\unsafe_q(\vec x)$ be an $\lrf$-formula. We define
$$\reach^n_{H,\unsafe}:= \exists^X \vec x \ (\reach^n_{H,q}(\vec x)\wedge
\unsafe_q(\vec x))$$
\end{definition}

Finally, starting from $\init(\vec x)$ at location $q_0$, if the unsafe state
is specified by $\unsafe(\vec x)$ or $\unsafe_{q'}(\vec x)$ (the later has the
end location $q'$ specified), we have the formulas expressing that the system
reaches the unsafe state in $n$ transitions:
and
$$\exists \vec x\ (\reach^n_{q_0\rightarrow q}(\vec x)\wedge \unsafe_q(\vec x))$$

\begin{corollary}
Let $H$ be an invariant-free hybrid automaton and $\unsafe$ be a subset of its
state space. Then $H$ reaches $\unsafe$ in $n$ steps of discrete jumps, if and
only if, $\reach^n_{H}$ is true.
\end{corollary}


\subsubsection{Automata with Invariants}\label{auto_inv}

If the invariant conditions of a hybrid automaton is nontrivial, we need to
ensure that before making a jump, the system always stays in the invariant of
its current mode. This requires the use of $\exists\forall$-sentences in the
encoding.

\begin{remark}
It is important to note that in this case, we need to require that the
$\flow_q$ predicates are graphs of single continuous functions of the form $\vec
x_t = f_q(\vec x_0, t)$. This is because the $\forall$-quantifiers will quantify
over all possible states in $\flow_q$, as will be shown in the following
encoding. In that case, if $\flow_q$ is nondeterministic, the encoding would be
wrong in requiring that all possible flows must satisfy the invariants, while
only the selected path needs to satisfy them.

It is possible to relax such an requirement by allowing that the nondeterminacy
in $\flow_q$ can be parameterized, such that we can existentially quantify over
the parameters to select a deterministic branch of a $\flow_q$.
\end{remark}
\paragraph{The Depth $0$ Case.} First, consider the reachable states of $H$ in
the initial mode, before making any discrete jump. In this case, the system
evolves according to the flow of the initial state.

Compared to the case for invariant-free automaton, we need to check whether
before any jumping conditions is met, $H$ stays in the same mode satisfying the
invariants. This requires universal quantification over all the possible values
for the continuous variables before the jumping point.

The formula that encodes all the possible $\vec x_0^t$ that the system can
reach in the initial mode is the following:
\begin{multline*}
\reach^0_{H,q_0} (\vec x_0^t):=\ \exists^X \vec x_0 \exists^{I_t}
t_0\forall^{[0,t_0]} t\forall^X \vec x\\ \Big(\init_{q_0}(\vec x_0)\wedge
\flow_q(\vec x_0^t, \vec x_0, t_0)\wedge (\flow_q(\vec x, \vec x_0,
t)\rightarrow\inv_{q_0}(\vec x))\Big)
\end{multline*}
\paragraph{The Depth $k+1$ Case.} Next, consider the induction case in
which
the system makes a discrete jump from a previous mode. Assume that
$\reach^k_{H,q'}$ are defined for any $q'\in Q$. We have:
\begin{multline*}
\reach^{k+1}_{H,q}(\vec x_{k+1}^t):=  \exists^X \vec x_k^t \exists^X \vec
x_{k+1}\exists^{T} t_{k+1}\forall^{[0,t_{k+1}]}t\forall^X \vec x \\
\bigvee_{q'\in Q} (\reach^k_{H,q'} (\vec x_k^t) \wedge \jump_{q'\rightarrow
q}(\vec x_k^t, \vec x_{k+1}) \wedge \flow_{q}(\vec x_{k+1}^t, \vec x_{k+1},
t_{k+1})\\
\wedge(\flow_q(\vec x, \vec x_{k+1}, t)\rightarrow \inv_q(\vec x)))
\end{multline*}
In all, the set of all reachable states of the system, after making $n$
transitions from $q_0$ is encoded by:
$$\reach^n_{H}(\vec x) := \bigvee_{q'\in Q} \reach^n_{H,q'}(\vec x).$$

\begin{proposition}\label{with-inv}
Let $H = \langle X, Q, \flow, \jump, \inv, \init \rangle$ be a general hybrid
automaton. Then for any $\vec a\in \mathbb{R}^n$, $\reach^n_q(\vec a)$ iff there
exists a depth-$n$ trajectory $\xi\in\llbracket H\rrbracket$ such that $\xi(n,
t) = \vec a$ for some $t\in\mathbb{R}$, and $\sigma_{\xi}(n) = q$.
\end{proposition}

\subsection{Solving Bounded $\delta$-Reachability}

We focus on the problem of bounded $\delta$-Reachability, defined as follows.

\begin{definition}[Bounded $\delta$-Reachability]
Let $H$ be a hybrid automaton such that the state space of $H$ is a bounded
set. Let $U$ be a subset of $X$. Let $n\in \mathbb{N}$, and $T\in \mathbb{R}$ a
bounded interval. The bounded $\delta$-reachability asks for one of the
following decisions:
\begin{itemize}
\item $\delta$-$\unsafe$: $H^{\delta}$ reaches $\unsafe^{-\delta}$.
\item $\safe$: $H$ does not reach $U$ in $n$ steps within time $T$.
\end{itemize}
When the two cases overlap, either answer can be returned.
\end{definition}

\begin{remark}
There are three bounds here. First, the state space $X$ and the time duration
$T$ are bounded. These two constraints ensure that the variables that will
appear in the logical encoding are bounded. Second, the number of steps is
bounded. This allows us to encode the problem with a finite formula.
\end{remark}


\begin{lemma}\label{bmclemma}
Let $H$ be a hybrid automaton, $\unsafe$ a subset of its state space, and
$n\in\mathbb{N}$. We have:
\begin{itemize}
\item If $(\reach^n_{H,\unsafe})^{-\delta}$ is true, then $H^{\delta}$ is unsafe.
\item If $\reach^n_{H,\unsafe}$ is false, then $H$ is safe up to $n$.
\end{itemize}
\end{lemma}

\begin{proposition}\label{equiv-delta}
$(\reach_{H,q}^n(\vec a))^{-\delta}$ iff there is a trajectory $\xi\in
\llbracket H^{\delta}\rrbracket$ such that $\xi(n, t) = \vec a$ and
$\sigma_{\xi}(n) = q$.
\end{proposition}

\begin{theorem}
Let $\mathcal{F}$ be a set of computable functions. There exists an algorithm
such that, for any given $\lrf$-representable $H$ and an unsafe region
$\unsafe$, and a time bound $T$, decide the bounded $\delta$-reachability
problem for $H$.
\end{theorem}

It is clear that all we need is a $\delta$-complete decision procedure to solve
the bounded $\delta$-reachability problems.

\begin{definition}[$\delta$-Complete Bounded Model Checking]
We say a bounded model checking algorithm is $\delta$-complete, if it solves
the $\delta$-reachability problem correctly.
\end{definition}
It is clear that Algorithm \ref{delta-bmc} is $\delta$-complete if it uses a
$\delta$-complete decision procedure.
\begin{algorithm}\caption{$\delta$-Complete Bounded Model
Checking}\label{delta-bmc}

\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{An $\lrf$-represented hybrid automaton $\varphi = \langle X, Q, \flow,
\jump, \inv, \init\rangle$, time bound $T\in \mathbb{R}$, depth $n$}
\Output{Safe or $\delta$-Unsafe}
\BlankLine
$\reach_{H}(0,q_0,\vec x_0') \leftarrow \exists^X \vec
x_0\exists^{[0,T]}t_0\Big( \init_{q_0}(\vec x_0)\wedge \flow_{q_0}(\vec x_0',
\vec x_0, t_0)\Big)$\\
$k\leftarrow 0$\\
\While{$k<n$}
{
$\reach_{H}(k+1, q, \vec x_{k+1}') \leftarrow \exists^X\vec x_k'\exists^X
x_{k+1}\exists^{[0,T]}t_{k+1} \bigvee_{q\in Q}\Big(\reach_{H}(k, q, \vec
x_k')\wedge \flow(\vec x_k', \vec x_k, t_k)\wedge \forall^X \vec
x\forall^{[0,t_k]} t (\flow(\vec x, \vec x_k', t)\rightarrow \inv(\vec
x))\Big)$\\
$k\leftarrow k+1$
}
$\reach_{H,U} \leftarrow \exists \vec x(\reach_{H}(n, q, \vec x)\wedge
\unsafe(\vec x))$
\\
\eIf{$\reach_{H,U}$ is {\sf $\delta$-true}}
{$H$ is {\sf $\delta$-unsafe}}
{$H$ is {\sf safe} up to depth $n$ within time bound $T$}
\end{algorithm}




\subsection{Complexity Results}


We have reduced the bounded $\delta$-reachability problems to the decision
problems of $\lrf$-sentences. Thus, we can obtain the following complexity
results of the reachability problems.


\begin{theorem}
Suppose all the functions in the descriptionof $H$ is in Type 2 complexity class
$\mathsf{C}$. Then deciding the bounded $\delta$-Reach problem of Depth $n$, in
time bounded by $T$, for an invariant-free $H$ is in $\np^{\mathsf{C}}$, and the
problem for $H$ with invariant is in $\Sigma_2^{\mathsf{C}}$.
\end{theorem}

\begin{proof}
Note that the formula $\reach_{H,\unsafe}$  is exponential in the size of the
description of $H$. However, we can nondeterministically select a sequence of
$n$ modes, and check if reachability can be witnessed.

(i) For an invariant-free $H$, the formula  encoding one possible sequence of
$n$ steps of mode change is of the form:
\begin{eqnarray*}
& &\exists \vec x_0 \exists \vec x_0'\exists t_0\cdots \exists \vec
x_{n-1}\exists\vec x_{n-1}'\exists t_{n-1}\\
& &\Big(\init(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0', t_0)\wedge
\jump_{q_0\rightarrow q_1}(\vec x_0', \vec x_1)\wedge \cdots\\
& &\wedge \flow_{q_{n-1}}(\vec x_{n-1}, \vec x_{n-1}', t_{n-1}) \wedge
\unsafe(\vec x_{n-1}')\Big)
\end{eqnarray*}
where $q_1,...,q_{n-1}$ are random modes in $Q$ ($q_0$ is always the initial
one). This formula is polynomial in $H$, $n$, $T$. Thus, we can use the
nondeterministic machine to randomly first select such a formula in polynomial
time, and then $\delta$-decide its truth value, using the $\mathsf{C}$ oracle.
In all, the computation can be performed by a nondeterministic machine with a
$\mathsf{C}$-oracle in polynomial time. Thus, the $\delta$-reachability problem
is in $\mathsf{NP^C}$, following . On the other hand, any of the predicate, for
instance $\init(\vec x_0)$, is allowed to be an arbitrary quantifier-free
$\lrf$-formula. Thus it can encode any propositional logic formula as needed in
Corollary~\ref{Completeness}.

(ii) For a general $H$, the formula encoding one possible sequence of $n$ steps
of mode change is of the form:
\begin{eqnarray*}
& &\exists \vec x_0 \exists \vec x_0'\exists t_0\cdots \exists \vec
x_{n-1}\exists\vec x_{n-1}'\exists t_{n-1} \forall \vec x
\forall^{[0,t_0]}t_0'\cdots \forall^{[0,t_{n-1}]}t_{n-1}'\\
& &\Big(\init(\vec x_0)\wedge \flow_{q_0}(\vec x_0, \vec x_0', t_0)\wedge
\jump_{q_0\rightarrow q_1}(\vec x_0', \vec x_1)\\
& &\wedge (\flow_{q_0}(\vec x, \vec x_0, t_0')\rightarrow \inv_{q_0}(\vec
x))\wedge \cdots\\
& &\wedge\jump_{q_{n-2}\rightarrow q_{n-1}}(\vec x_{n-2}', \vec x_{n-1}) \wedge
\flow_{q_{n-1}}(\vec x_{n-1}, \vec x_{n-1}', t_{n-1})\\
& &\wedge (\flow_{q_{n-1}}(\vec x, \vec x_{n-1}, t_{n-1}')\rightarrow
\inv_q(\vec x))\\
& &\wedge \unsafe(\vec x_{n-1}')\Big)
\end{eqnarray*}
where $q_1,...,q_{n-1}$ are random modes in $Q$. Using a nondeterministic
Turing machine, such a formula is first selected in polynomial time, and its
truth value is $\delta$-decided as a $\Sigma_2$-sentence. Thus similarly as the
invariant-free case, it follows from Theorem~\ref{compmain} and
Corollary~\ref{Completeness} that the $\delta$-reachability problem is
$\mathsf{\Sigma_2^C}$-complete.
\end{proof}

\begin{remark}
The input parameters of the $\delta$-reachability problem are: the depth $n$,
the time bound $T$, the length of the $\lrf$-description of $H$, and the error
bound $\delta$.
\end{remark}

\section{Related Work}\label{discuss}
Formal work along this line started in the work~\cite{}.
Franzle defined a notion of noise in hybrid systems, and proved that problems
with polynomial maps are solvable in a compact space. Raschan later generalizes
this result in \cite{} and obtained more positive result
(Quasi-semidecidablity). However, results like this has been very sensitive to
the definition of noise or approximations. For instance, in \cite{} it is shown
that other definitions of noise and robustness still leads to undecidability.
These results are in general theoretical in nature and does not lend themselves
to practical solving techniques. {\bf More papers on nonlinear tools ()}

\section{Experiments}\label{experiments}

We implemented a bounded model checking {\tt dReach} using the
techniques shown above. The tool relies on our SMT solver {\tt dReal}~\cite{},
which provides $\delta$-decisions on $\lrf$-formulas. The tool is
open-source. The latest version and all the benchmarks are at {\tt
http://cmacs.cs.cmu.edu/dReach}.We describe more details of our tool in~\cite{}.
All the experiments are ran on a {\bf what} machine. 

Here we list results on several nonlinear hybrid models that we believe are
beyond the scope of existing tools.
The {\sf Cardiac Cell Model}... The {\sf Power Grid Model}... The {\sf Legged
Robotics Model}... All of them contain nonlinear ODEs and frequent use of
trignometric and exponential functions, and model realistic systems in practice.
More details of the models are in the Appendix. 

The columns in the table shows the following data, from left to right. {\sf
depth} is the unwinded depth of the model for bounded model checking. Again, we
only count the number of discrete mode switching, which is usually small in
practice. {\sf $\delta$} is error bound we set, which in this case is the size
of the interval on the output solution. {\sf \#vars} is the number of real
variables and {\sf \#atoms} is the number of atomic
formulas in the formula. {\sf \#ODE} shows the number of differential equations
involved. \#{\sf icp-solve} \#{ode-solve} are the number of ICP solving steps (a
pair of pruning and branching steps) and ODE solving steps, respectively.
\#{\sf conflict} is the number of conflict observed (and also backtracking) in
the high-level DPLL(T) framework. {result} is the final answer of the tool. {\sf
time} and {\sf mem} show that CPU time and memory cost. 

\begin{center}
\begin{table}[h]
\centering
\begin{tabular}{||c|c|| c| c| c||c|c|c||c|c|c||}
\hline
depth & $\delta$ & \#vars  &\#atoms &\#ODEs &\#icp-solve &
\#ode-solve& \#conflict & result & time & mem \\
\hline
\multicolumn{11}{|c|}{Benchmark Set: AddArray} \\
\hline
 6 & 10 & 3 & 0  & 1& {\tt UNSAT}& 0.06s &0.04s\\
 8 & 36 & 10 & 0 & 1 &{\tt UNSAT}& 0.09s &303.03s \\
 31 & 1634 & 735 & 0 & 1& {\tt UNSAT}& 0.93s & mem-out \\
 6 & 10 & 3 & 0  & 1& {\tt UNSAT}& 0.06s &0.04s\\
 8 & 36 & 10 & 0 & 1 &{\tt UNSAT}& 0.09s &303.03s \\
 31 & 1634 & 735 & 0 & 1& {\tt UNSAT}& 0.93s & mem-out \\
\hline
\multicolumn{11}{|c|}{Benchmark Set: MultiArray-1} \\
\hline
 5 & 10 & 3 & 20 & 1&{\tt UNSAT}& 0.23s  & 0.02s   \\
 7 & 30 & 8 & 28 & 1 &{\tt UNSAT}& 0.04s & 7.21s   \\
 8 & 121 & 40 & 32 &1 &{\tt UNSAT}& 0.12s & 56.46s   \\
 16 & 817 & 320 & 64 & 1 &{\tt UNSAT}& 0.32s  & mem-out\\
26 & 1687 & 670 & 104 & 2 &{\tt SAT} & 87.45s & mem-out\\
\hline
\multicolumn{11}{|c|}{Benchmark Set: MultiArray-2} \\
\hline
 9 & 208 & 75 & 36 & 1 &{\tt UNSAT}& 0.73s & 244.85s \\
 10 & 295 & 110 & 40 & 1 &{\tt UNSAT}& 0.11s & 123.02s \\
 11 & 382 & 145 & 44 & 1 &{\tt UNSAT}& 0.12s & 3.96s \\
 20 & 1165 & 460 & 80 & 1 &{\tt UNSAT}& 0.30s & mem-out  \\
26 & 1687 & 670 & 104 & 2 &{\tt SAT} & 65.72s & mem-out \\
\hline
\end{tabular}
\caption{Experimental Results}
\end{table}
\end{center}

\section{Conclusion}


We believe the notion of $\delta$-complete methods lead to a new framework that
resolves other problems as well, which can be of considerable theoretical
interest. Currently the precise versions of these problems are open, but we
believe in a $\delta$-perturbed picture they all allow definite answers. We
will show discuss these directions for short and leave some conjectures here.





\bibliographystyle{abbrv}
\bibliography{tau}

\newpage
\section*{Appendix}

\subsection*{Proof of Proposition \ref{equiv-delta}}
\begin{proof}
Prove by induction on $n$.

(i) Case $n=0$.

Suppose $(\reach^0_{H,q}(\vec a_0^t))^{-\delta}$ is true, where $\vec a_0\in \mathbb{R}^n$. Then there exists $\vec a_0^t\in \mathbb{R}^n$ and $t_0\in \mathbb{R}$ such that
$$(\init_{q_0}(\vec a_0))^{-\delta}\wedge(\flow_{q_0}(\vec a_t, \vec a_0, t_0))^{-\delta}.$$
Following Definition~\ref{trajec} and Definition~\ref{lrf-definition}, there exists a trajectory $\xi\in \llbracket H\rrbracket$ such that
$$\xi(0,0) = \vec a_0$$
and
$$\xi(0,t_0) = \vec a_0^t$$
with
$$\sigma^H_{\xi}(0) = q_0.$$
Then, since $\unsafe(\vec a^t)$, we know that $H$ reaches $\unsafe$ by Definition~\ref{reachability}.

On the other hand, if there is a $\xi\in \llbracket H\rrbracket$ such that $\xi(0,t)$ is in $\unsafe$ for some $t$. Then let $\vec a_0 = \xi(0,0)$, $\vec a_0^t = \xi(0,t)$, and $t_0 = t$. Following the definitions, they witness that $\reach^0_{H,\unsafe}$ is true.

(ii) Case $n=k+1$.

Suppose $\reach_{H,q}^{k+1}(\vec a^t)$ is true for some $\vec a^t\in\mathbb{R}^n$. Then there exists $\vec b\in \mathbb{R}^n$, $\vec a\in \mathbb{R}$, $t_a\in \mathbb{R}$, and $q'\in Q$ such that
$$\reach_{H,q'}^k(\vec b) \wedge \jump_{q\rightarrow q'}(\vec b, \vec a)\wedge \flow(\vec a^t, \vec a, t_a).$$
By inductive hypothesis, since $\reach_{H,q'}^k(\vec b)$, there exists $\xi\in\llbracket H\rrbracket$ and $t_b\in mathbb{R}$ such that $\xi(k, t_b) = \vec b$.


Now consider the extension of $\xi$ into $\xi'$ satisfying:
$$(q', q, \vec b, \vec a)\in \llbracket \jump_{q\rightarrow q'}\rrbracket$$
and
$$(\vec a, \vec a^t, t_a)\in \llbracket \flow_q \rrbracket$$
where $\xi'(k,t_b) = \vec b$ and $\xi'(k+1, t_a) = \vec a^t$. Following Definition~\ref{trajec} and Definition~\ref{lrf-definition}, $\xi'\in \llbracket H\rrbracket$.

On the other hand, suppose there is a trajectory $\xi\in\llbracket H\rrbracket$ such that $\xi(k+1, t_a) = \vec a$. By Definition~\ref{trajec} and Definition~\ref{lrf-definition}, for some $q'\in Q$ we have
$$\reach^n_{H,q'}(\xi(k,t_b))$$
where $t_b\in\mathbb{R}$ satisfying
$$(q', q, \xi(k,t_b), \xi(k+1,t_b))\in \llbracket \jump_{q'\rightarrow q} \rrbracket$$
and
$$(\xi(k+1,t_a), \xi(k+1,t_b), t_a - t_b)\in \llbracket \flow_q\rrbracket$$
Thus we have
$$\reach_{H,q'}(\vec b)\wedge \jump(q',q,\vec b, \vec a)\wedge \flow(\vec a, \vec a^t, t_a-t_b),$$
which means that $\reach_{H,q}(\vec a^t)$ is true.


\end{proof}

\begin{proposition}
Let $H$ be an invariant-free hybrid automaton. Then for any $\vec a\in
\mathbb{R}^n$, $\reach^n_q(\vec a)$ iff there exists a depth-$n$ trajectory
$\xi\in\llbracket H\rrbracket$ such that $\xi(n, t) = \vec a$ for some
$t\in\mathbb{R}$, and $\sigma_{\xi}(n) = q$ .
\end{proposition}


\begin{proof}
We do induction on $n$.

(i) Case $n=0$.

Suppose $\reach^0_{H,q}(\vec a_0^t, \vec a_0, t_0)$ is true, where $\vec a_0\in
\mathbb{R}^n$, $\vec a_0^t\in \mathbb{R}^n$, $t_0\in \mathbb{R}$. Then
$$\init_{q_0}(\vec a_0)\wedge\flow_{q_0}(\vec a_t, \vec a_0, t_0) \wedge
\unsafe(\vec a^t).$$
Following Definition~\ref{trajec} and Definition~\ref{lrf-definition}, there
exists a trajectory $\xi\in \llbracket H\rrbracket$ such that
$$\xi(0,0) = \vec a_0$$
and
$$\xi(0,t_0) = \vec a_0^t$$
with
$$\sigma^H_{\xi}(0) = q_0.$$
Then, since $\unsafe(\vec a^t)$, we know that $H$ reaches $\unsafe$ by
Definition~\ref{reachability}.

On the other hand, if there is a $\xi\in \llbracket H\rrbracket$ such that
$\xi(0,t)$ is in $\unsafe$ for some $t$. Then let $\vec a_0 = \xi(0,0)$, $\vec
a_0^t = \xi(0,t)$, and $t_0 = t$. Following the definitions, they witness that
$\reach^0_{H,\unsafe}$ is true.

(ii) Case $n=k+1$.

Suppose $\reach_{H,q}^{k+1}(\vec a^t)$ is true for some $\vec
a^t\in\mathbb{R}^n$. Then there exists $\vec b\in \mathbb{R}^n$, $\vec a\in
\mathbb{R}$, $t_a\in \mathbb{R}$, and $q'\in Q$ such that
$$\reach_{H,q'}^k(\vec b) \wedge \jump_{q\rightarrow q'}(\vec b, \vec a)\wedge
\flow(\vec a^t, \vec a, t_a).$$
By inductive hypothesis, since $\reach_{H,q'}^k(\vec b)$, there exists
$\xi\in\llbracket H\rrbracket$ and $t_b\in mathbb{R}$ such that $\xi(k, t_b) =
\vec b$.


Now consider the extension of $\xi$ into $\xi'$ satisfying:
$$(q', q, \vec b, \vec a)\in \llbracket \jump_{q\rightarrow q'}\rrbracket$$
and
$$(\vec a, \vec a^t, t_a)\in \llbracket \flow_q \rrbracket$$
where $\xi'(k,t_b) = \vec b$ and $\xi'(k+1, t_a) = \vec a^t$. Following
Definition~\ref{trajec} and Definition~\ref{lrf-definition}, $\xi'\in \llbracket
H\rrbracket$.

On the other hand, suppose there is a trajectory $\xi\in\llbracket H\rrbracket$
such that $\xi(k+1, t_a) = \vec a$. By Definition~\ref{trajec} and
Definition~\ref{lrf-definition}, for some $q'\in Q$ we have
$$\reach^n_{H,q'}(\xi(k,t_b))$$
where $t_b\in\mathbb{R}$ satisfying
$$(q', q, \xi(k,t_b), \xi(k+1,t_b))\in \llbracket \jump_{q'\rightarrow q}
\rrbracket$$
and
$$(\xi(k+1,t_a), \xi(k+1,t_b), t_a - t_b)\in \llbracket \flow_q\rrbracket$$
Thus we have
$$\reach_{H,q'}(\vec b)\wedge \jump(q',q,\vec b, \vec a)\wedge \flow(\vec a,
\vec a^t, t_a-t_b),$$
which means that $\reach_{H,q}(\vec a^t)$ is true.
\end{proof}



\begin{proof}
We do induction on $n$.

(i) Case $n=0$.

Suppose $\reach^0_{H,q}(\vec a_0^t, \vec a_0, t_0)$ is true, where $\vec a_0\in
\mathbb{R}^n$, $\vec a_0^t\in \mathbb{R}^n$, $t_0\in \mathbb{R}$. Then
$$\init_{q_0}(\vec a_0)\wedge\flow_{q_0}(\vec a_t, \vec a_0, t_0)  \wedge
\unsafe(\vec a^t).$$
Following Definition~\ref{trajec} and Definition~\ref{lrf-definition}, there
exists a trajectory $\xi\in \llbracket H\rrbracket$ such that
$$\xi(0,0) = \vec a_0$$
and
$$\xi(0,t_0) = \vec a_0^t$$
with
$$\sigma^H_{\xi}(0) = q_0.$$
Then, since $\unsafe(\vec a^t)$, we know that $H$ reaches $\unsafe$ by
Definition~\ref{reachability}.

On the other hand, if there is a $\xi\in \llbracket H\rrbracket$ such that
$\xi(0,t)$ is in $\unsafe$ for some $t$. Then let $\vec a_0 = \xi(0,0)$, $\vec
a_0^t = \xi(0,t)$, and $t_0 = t$. Following the definitions, they witness that
$\reach^0_{H,\unsafe}$ is true.

(ii) Case $n=k+1$.

Suppose $\reach_{H,q}^{k+1}(\vec a^t)$ is true for some $\vec
a^t\in\mathbb{R}^n$. Then there exists $\vec b\in \mathbb{R}^n$, $\vec a\in
\mathbb{R}$, $t_a\in \mathbb{R}$, and $q'\in Q$ such that
$$\reach_{H,q'}^k(\vec b) \wedge \jump_{q\rightarrow q'}(\vec b, \vec a)\wedge
\flow(\vec a^t, \vec a, t_a).$$
By inductive hypothesis, since $\reach_{H,q'}^k(\vec b)$, there exists
$\xi\in\llbracket H\rrbracket$ and $t_b\in mathbb{R}$ such that $\xi(k, t_b) =
\vec b$.


Now consider the extension of $\xi$ into $\xi'$ satisfying:
$$(q', q, \vec b, \vec a)\in \llbracket \jump_{q\rightarrow q'}\rrbracket$$
and
$$(\vec a, \vec a^t, t_a)\in \llbracket \flow_q \rrbracket$$
where $\xi'(k,t_b) = \vec b$ and $\xi'(k+1, t_a) = \vec a^t$. Following
Definition~\ref{trajec} and Definition~\ref{lrf-definition}, $\xi'\in \llbracket
H\rrbracket$.

On the other hand, suppose there is a trajectory $\xi\in\llbracket H\rrbracket$
such that $\xi(k+1, t_a) = \vec a$. By Definition~\ref{trajec} and
Definition~\ref{lrf-definition}, for some $q'\in Q$ we have
$$\reach^n_{H,q'}(\xi(k,t_b))$$
where $t_b\in\mathbb{R}$ satisfying
$$(q', q, \xi(k,t_b), \xi(k+1,t_b))\in \llbracket \jump_{q'\rightarrow q}
\rrbracket$$
and
$$(\xi(k+1,t_a), \xi(k+1,t_b), t_a - t_b)\in \llbracket \flow_q\rrbracket$$
Thus we have
$$\reach_{H,q'}(\vec b)\wedge \jump(q',q,\vec b, \vec a)\wedge \flow(\vec a,
\vec a^t, t_a-t_b),$$
which means that $\reach_{H,q}(\vec a^t)$ is true.
\end{proof}

\begin{proposition} Let $\delta\in\mathbb{Q}^+\cup \{0\}$ and $H$ be given. We
always have $\llbracket H\rrbracket\subseteq \llbracket H^{\delta}\rrbracket.$
\end{proposition}
\begin{proof}
Let $\xi\in \llbracket H\rrbracket$ be any trajectory of $H$. Recall that for
any $\lrf$ sentence $\varphi$, $\varphi\rightarrow\varphi^{-\delta}$. Now since
$\xi$ satisfies the conditions in Definition~\ref{trajec}, by replacing each
predicate in the definition by their $\delta$-weakenings, we know $\xi\in
\llbracket H^{\delta}\rrbracket$.
\end{proof}
Note that then weakening of a deterministic hybrid automaton
is nondeterministic.


\begin{corollary}
Let $H$ be an invariant-free hybrid automaton and $\unsafe$ be a subset of its
state space. Then $H$ reaches $\unsafe$ in $n$ steps of discrete jumps, if and
only if, $\reach^n_{H}$ is true.
\end{corollary}

\begin{proof}
$H$ reaches $\unsafe$ in $n$ steps iff there is some $\xi\in \llbracket
H\rrbracket$ such that $\xi(n, t)\in \llbracket unsafe\rrbracket$. On the other
hand, we have shown that $\xi(n, t) = \vec a$ for some $t$ iff $\reach_H^n(\vec
a)$.
\end{proof}


\begin{lemma}\label{bmclemma}
Let $H$ be a hybrid automaton, $\unsafe$ a subset of its state space, and
$n\in\mathbb{N}$. We have:
\begin{itemize}
\item If $(\reach^n_{H,\unsafe})^{-\delta}$ is true, then $H^{\delta}$ is
unsafe.
\item If $\reach^n_{H,\unsafe}$ is false, then $H$ is safe up to $n$.
\end{itemize}
\end{lemma}

\begin{proof}
Following Proposition~\ref{equiv-delta}, if $(\reach^n_{H,\unsafe})^{-\delta}$
is true then there exists $\xi\in \llbracket H^{\delta}\rrbracket$ such that
$\xi(0,t)=\vec a$ for some $t$, such that
$$(\reach^n_{H,q}(\vec a))^{-\delta} \wedge (\unsafe(\vec a))^{-\delta}$$
is true. Thus $H^{\delta}$ is unsafe, witnessed by $\vec a$.

On the other hand, suppose $\reach^n_{H,\unsafe}$ is false. Following
Proposition~\ref{equiv-delta}, there does not exists any $\xi$ such that
$\xi(n,t) = \vec a$ and $\unsafe(\vec a)$ is true. Consequently, $H$ is safe up
to depth $n$.
\end{proof}



\begin{theorem}
Let $\mathcal{F}$ be a set of computable functions. There exists an algorithm
such that, for any given $\lrf$-representable $H$ and an unsafe region
$\unsafe$, and a time bound $T$, decide the bounded $\delta$-reachability
problem for $H$.
\end{theorem}

\begin{proof}
Since $H$ and $\unsafe$ are both $\lrf$-representable, $\reach_{H,unsafe}$ is an
$\lrf$-sentence. Following Corollary~\ref{weaken}, there exists an algorithm
that correctly decides:
\begin{itemize}
\item $\reach_{H,\unsafe}$ is false, or
\item $(\reach_{H,\unsafe})^{-\delta}$ is true.
\end{itemize}
Following Lemma~\ref{bmclemma}, the first case implies that $H$ is safe up to
depth $n$ within time bound $T$, and the second case implies that $H$ is unsafe.
\end{proof}



\subsection*{Some Examples and Figures}
\begin{example}
Let $H$ be defined as:
\begin{eqnarray*}
X &:& \mathbb{R}\\
Q &:& \{q_0, q_1\}\\
\flow_{q_0} &:& x = 1\\
\flow_{q_1} &:& dx/dt = 1\\
\jump_{q_0\rightarrow q_1} &:& x >1 \wedge x' = x\\
\init_{q_0} &:& x=1
\end{eqnarray*}
Note that the jump condition is not met for any trajectory of $H$. Thus for all
$\xi\in \llbracket H\rrbracket$,
$$\xi(0, t) = 1\mbox{ and }\xi(k,t)\mbox{ is undefined for any $k>0$.}$$
On the other hand, for any $\delta\in \mathbb{Q}^+$, we have that for any $a >
1$, there is some $\xi\in \llbracket H^{\delta}$ and some $t\in \mathbb{R}$ such
that
$$\xi(1, t) = a.$$
Consequently for any such $\delta$, the Hausdorff distance between the two
trajectory sets is
$$d_{H}(\llbracket H\rrbracket, \llbracket H^{\delta}\rrbracket) = \infty$$
in the generalized Skorokhod topology.
\end{example}



\end{document}

