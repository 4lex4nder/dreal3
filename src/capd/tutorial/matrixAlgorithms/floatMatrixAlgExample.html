<html>
<head>
<link rel=stylesheet type="text/css" href="../tutorial.css">
</head>
<body>

<h2>linear algebra algorithms - see the <a href="floatMatrixAlgExample.cpp">c++ source</a> of an example</h2>

<p>
This file provides a short description of algorithms implemented in file <span class="fileName">"capd/matrixAlgorithms/floatMatrixAlgorithms.hpp"</span> from CAPD package - for more details see the source file.
</p>
<h3>See also:</h3>
<ul>
<li><a href="../vectalg/vectalg.html">vectalg module</a> - implementation of classes Vector, Matrix, Norm</li>
<li><a href="matrixAlgorithms.html">matrixAlgorithms module</a> for algorithms on matrices</li>
</ul>

<h3>Content of this file:</h3>
<ul>
<li><a href="#gauss">Solving of linear equations by Gauss elimination</a></li>
<li><a href="#orthonormalize">Orthonormalization of a matrix</a></li>
<li><a href="#QRdecompose">QR decomposition</a></li>
<li><a href="#diagonalization">Diagonalization of a symmetric matrix</a></li>
<li><a href="#radius">Spectral radius of a symmetric matrix</a></li>
<li><a href="#maxeig">Maximal eigenvalue a symmetric matrix</a></li>
<li><a href="#inverse">Computation of inverse matrix</a></li>
</ul>


<a name="gauss"></a>
<!-- ----------------------------- Gauss elimination --------------------------------------- -->
<h3>Solving of linear equations by Gauss elimination</h3>
<p>The following function solves system of linear equations by using Gauss elimination algorithm</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
   VectorType <span class="funcName">gauss</span>(MatrixType a, VectorType b);
</pre>
<p>Since both arguments are modified in this function, they are copied to the actual arguments <font face="monospace">a,b</font></p>
<p>Example of usage:</p>
<pre>
   // we create a matrix
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data);
   Vector&lt;<span class="keyword">double</span>,<span class="const">0</span>&gt; v = P.row(<span class="const">0</span>);
   // here we call the function gauss
   Vector&lt;<span class="keyword">double</span>,<span class="const">0</span>&gt; solution = gauss(P,v);
   std::cout &lt;&lt; "gauss(P,v)=" &lt;&lt; solution &lt;&lt; std::endl;
   // this should be close to v
   std::cout &lt;&lt; "verification of the result:\nP*gauss(P,v)=" &lt;&lt; P*solution &lt;&lt; std::endl;
</pre>


<a name="orthonormalize"></a>
<!-- ------------------------------ Orthonormalization ------------------------------------------- -->
<h3>Orthonormalization of a matrix</h3>
<p>
The following function orthonormalizes columns of a nonsingular matrix. The function throws an exception when the matrix is singular.
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   void <span class="funcName">orthonormalize</span>(MatrixType&amp; Q);
</pre>
<p> The above function performs Gramm-Schmidt orthonormalization of columns of matrix Q sorted by decreasing norm. The argument Q is modified by the function and after calling orthonormalize(Q), the matrix Q contains result of this function.</p>
<p>Example of usage:</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; Q(<span class="const">4</span>,<span class="const">4</span>,data);
   std::cout &lt;&lt; "orthonormalization of Q=" &lt;&lt; Q &lt;&lt; std::endl;
   orthonormalize(Q);
   std::cout &lt;&lt; "is equal to " &lt;&lt; Q &lt;&lt; std::endl;
</pre>

<a name="QRdecompose"></a>
<!-- ------------------------------ QR decomposition ------------------------------------------- -->
<h3>QR decomposition</h3>
<p>
The following function computes QR-decomposition of a square nonsingular matrix.
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   void <span class="funcName">QR_decompose</span>(<span class="keyword">const</span> MatrixType&amp; A, MatrixType&amp; Q, MatrixType&amp; R);
</pre>
<p>
As a result we obtain orthogonal and upper triangular matrix. First argument of the function is a matrix to be decomposed. Matrices Q and R are modified by the function and contain the result.
</p>
<p>Example of usage:</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data), Q(<span class="const">4</span>,<span class="const">4</span>), R(<span class="const">4</span>,<span class="const">4</span>);
   QR_decompose(P,Q,R); 
   // P should be equal to Q*R
   std::cout &lt;&lt; "QR decomposition of P:" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Q=" &lt;&lt; Q &lt;&lt; std::endl;
   std::cout &lt;&lt; "R=" &lt;&lt; R &lt;&lt; std::endl;
   std::cout &lt;&lt; "verification if P-Q*R is close to zero\n";
   std::cout &lt;&lt; "P-Q*R=" &lt;&lt; P-Q*R &lt;&lt; std::endl;
</pre>      
<p>The function throws an exception when the matrix is singular.</p>


<a name="diagonalization"></a>
<!-- ------------------------------ diagonalization ------------------------------------------- -->
<h3>Diagonalization of a symmetric matrix</h3>
<p>The following function performs Jacobi rotation algorithm for computing diagonalization of a square symmetric matrix. </p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   <span class="keyword">int</span> <span class="funcName">symMatrixDiagonalize</span>(<span class="keyword">const</span> MatrixType&amp; A, MatrixType&amp; D, <span class="keyword">typename</span> MatrixType::ScalarType diagonalizingRelTolerance = <span class="keyword">typename</span> MatrixType::ScalarType(<span class="const">1e-5</span>));
</pre>
<p>The argument D contains the result of the function. The last argument is a diagonalizing tolerance we want to obtain, namely if by 'd' and 's' we denote
<ul>
<li> d = <font face="symbol">S</font><sub>i=1,...,n</sub> (A<sub>ii</sub>)<sup>2</sup></li>
<li> s = <font face="symbol">S</font><sub>1=1,...,n</sub> <font face="symbol">S</font><sub>j=1,...,i-1</sub>(A<sub>ij</sub>)<sup>2</sup></li>
</ul>
<p>the algorithm stops when s &lt; d*diagonalizingRelTolerance or the next iteration would worsen the estimation. 
It should be noted that the procedure does not guarantee that such tolerance is achieved. 
This procedure is the first step in functions which compute spectral radius and maximal eigenvalue of a symmetric matrix.
</p>
<p>Example of usage:</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data), D(<span class="const">4</span>,<span class="const">4</span>);
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; S = <span class="const">0.5</span>*(P+Transpose(P));
   // diagonalization of S=0.5*(P+P^T)
   symMatrixDiagonalize(S,D);
   std::cout &lt;&lt; "Diagonalization of <span class="const">0.5</span>*(P+P^T)=" &lt;&lt; D &lt;&lt; std::endl;
</pre>

<a name="radius"></a>
<!-- ------------------------------ spectral radius ------------------------------------------- -->
<h3>Spectral radius of a symmetric matrix</h3> 
<p>
The following function computes an upper bound for spectral radius of a symmetric matrix.
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   <span class="keyword">typename</span> MatrixType::ScalarType <span class="funcName">spectralRadiusOfSymMatrix</span>(<span class="keyword">const</span> MatrixType &amp;A, <span class="keyword">typename</span> MatrixType::ScalarType diagonalizingRelTolerance = <span class="keyword">typename</span> MatrixType::ScalarType(<span class="const">1e-5</span>));
</pre>
<p>First, the function computes matrix which has the same eigenvalues and which is close to diagonal, next upper bound is computed from Gerschgorin theorem</p>
<p>Example of usage:</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data);
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; S = <span class="const">0.5</span>*(P+Transpose(P));
   std::cout &lt;&lt; "spectralRadiusOfSymMatrix(S)=" &lt;&lt; spectralRadiusOfSymMatrix(S) &lt;&lt; std::endl;
</pre>

<a name="maxeig"></a>
<!-- ------------------------------ max eigenvalue ------------------------------------------- -->
<h3>Maximal eigenvalue of a symmetric matrix</h3>
<p>
The following function computes an upper bound for maximal eigenvalue of a symmetric matrix.
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   <span class="keyword">typename</span> MatrixType::ScalarType <span class="funcName">maxEigenValueOfSymMatrix</span>(<span class="keyword">const</span> MatrixType &amp;A, <span class="keyword">typename</span> MatrixType::ScalarType diagonalizingRelTolerance = <span class="keyword">typename</span> MatrixType::ScalarType(<span class="const">1e-5</span>));
</pre>
<p>First, the function computes matrix which has the same eigenvalues and which is close to diagonal, next upper bound is computed from Gerschgorin theorem</p>

<p>Example of usage:</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data);
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; S = <span class="const">0.5</span>*(P+Transpose(P));
   std::cout &lt;&lt; "maxEigenValueOfSymMatrix(S)=" &lt;&lt; maxEigenValueOfSymMatrix(S) &lt;&lt; std::endl;
</pre>

<a name="inverse"></a>
<!-- ------------------------------ inverse matrix ------------------------------------------- -->
<h3>Computation of inverse matrix</h3>
<p>
The matrixAlgorithm module implements two functions for computing the inverse of a matrix. 
First function decomposes a matrix A=Q*R, where Q-orthogonal, R-upper diagonal and compute A<sup>-1</sup> = R<sup>-1</sup>*Q<sup>T</sup>
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   MatrixType <span class="funcName">inverseMatrix</span>(<span class="keyword">const</span> MatrixType &amp;A);
</pre>
<p>
The second function (recommended) computes the inverse matrix using Gauss elimination algorithm
</p>
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MatrixType&gt;
   MatrixType <span class="funcName">gaussInverseMatrix</span>(<span class="keyword">const</span> MatrixType &amp;A);
</pre>
<p>
Example of usage:
</p>
<pre>
   <span class="keyword">double</span> data[] = {1,2,1,2,2,2,2,0,1,97,3,4,1,19,1,15};
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; P(<span class="const">4</span>,<span class="const">4</span>,data);
   Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt;  invP = inverseMatrix(P);
   std::cout &lt;&lt; "Inverse of P by using QR-decomposition:" &lt;&lt; invP &lt;&lt; std::endl;
   std::cout &lt;&lt; "verification: P*inverseMatrix(P)=" &lt;&lt; P*invP &lt;&lt; std::endl;

   invP = gaussInverseMatrix(P);
   std::cout &lt;&lt; "Inverse of P by using Gauss elimination:" &lt;&lt; invP &lt;&lt; std::endl;
   std::cout &lt;&lt; "verification: P*gaussInverseMatrix(P)=" &lt;&lt; P*invP &lt;&lt; std::endl;
</pre>
<hr>
<p><small>Author: Daniel Wilczak, last modified on July 7, 2008.</small></p>

</body>
</html>