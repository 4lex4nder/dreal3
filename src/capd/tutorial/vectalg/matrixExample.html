<html>
<head>
<link rel=stylesheet type="text/css" href="../tutorial.css">
</head>
<body>

<h2><span class="keyword">template class</span> Matrix&lt;<span class="keyword">typename</span> ScalarType,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols&gt; - see the <a href="matrixExample.cpp">c++ source</a> of an example</h2>
<p>
This file provides a short description on how to use class Matrix from CAPD package - for more details see header file <font face="monospace" color="maroon"><b>"capd/vectalg/Matrix.h"</b></font>
</p>
<h3>See also</h3>
<ul>
<li><a href="vectorExample.html">class Vector</a></li>
<li><a href="normExample.html">class Norm</a></li>
<li><a href="../matrixAlgorithms/matrixAlgorithms.html">matrixAlgorithms module</a> for algorithms on matrices</li>
</ul>

<h3>Content of this file:</h3>
<ul>
<li><a href="#create">How to create a matrix</a></li>
<li><a href="#arrays">How to create an array of matrices</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#rowcol">Rows and columns of matrices as vectors</a></li>
<li><a href="#iterators">Low level iterators</a></li>
<li><a href="#miterators">Matrix iterators</a></li>
<li><a href="#basicop">Basic operations on matrices</a></li>
<li><a href="#member">Other member functions</a></li>
<li><a href="#imatrix">Operations for interval matrices only</a></li>
</ul>

<p>
The class Matrix is defined in the namespace <span class="keyword">capd::vectalg</span>. The <span class="keyword">template</span> class Matrix has three parameters - type of elements stored in a matrix, number of rows and number of columns
</p>
<pre>
 <span class="keyword">template class</span> Matrix&lt;<span class="keyword">typename</span> ScalarType, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols&gt;
</pre>
<p>
If both arguments rows and cols are greater than zero, the matrix is represented as an internal one-dimensional array 
with suitable indexing. If rows or cols is equal to zero, the matrix has a pointer to the allocated array
</p>
<p>
The following lines define new names for four dimensional vectors
</p>
<pre>
   <span class="keyword">typedef</span> capd::vectalg::Vector&lt;<span class="keyword">double</span>,<span class="const">4</span>&gt; DVector4D;
   <span class="keyword">typedef</span> capd::vectalg::Vector&lt;interval,<span class="const">4</span>&gt; IVector4D;
</pre>
<p>
The following lines define new names for vectors of arbitrary length
</p>
<pre>
   <span class="keyword">typedef</span> capd::vectalg::Vector&lt;<span class="keyword">double</span>,<span class="const">0</span>&gt; DVector;
   <span class="keyword">typedef</span> capd::vectalg::Vector&lt;interval,<span class="const">0</span>&gt; IVector;
</pre>
<p>
The following lines define new names for square matrices 4x4 both for doubles and intervals
</p>
<pre>
   <span class="keyword">typedef</span> capd::vectalg::Matrix&lt;<span class="keyword">double</span>,<span class="const">4</span>,<span class="const">4</span>&gt; DMatrix4D;
   <span class="keyword">typedef</span> capd::vectalg::Matrix&lt;interval,<span class="const">4</span>,<span class="const">4</span>&gt; IMatrix4D;
</pre>
<p>
The following lines define new names for matrices of arbitrary size
</p>
<pre>
   <span class="keyword">typedef</span> capd::vectalg::Matrix&lt;<span class="keyword">double</span>,<span class="const">0</span>,<span class="const">0</span>&gt; DMatrix;
   <span class="keyword">typedef</span> capd::vectalg::Matrix&lt;interval,<span class="const">0</span>,<span class="const">0</span>&gt; IMatrix;
</pre>

<!-- ################################################################################# -->

<a name="create"></a>
<h3>How to create a matrix</h3>

<p>The following line creates a 4x4 matrix filled with zeros</p>
<pre>
   DMatrix4D M;
</pre>
<p>
The matrix <font face="monospace">N</font> will be a 4x5 dimensional interval matrix filled with zeros
</p>
<pre>
   IMatrix N(<span class="const">4</span>,<span class="const">5</span>);
</pre>
<p>
If one wishes to initialize the matrix when creating an object, he or she can define a table which contains the rows of a matrix and send it to constructor.
The following line creates a matrix from a given table of numbers. The number of elements in a table should be greater or equal to the number of coefficients in created matrix. The table should contain rows of the matrix. 
</p>
<pre>
   <span class="keyword">double</span> data[] = {1.,2.,3.,4.,4.,3.,2.,1.,1.,2.,3.,4.};
   <span class="keyword">const</span> DMatrix P(<span class="const">3</span>,<span class="const">4</span>,data);
   DMatrix Q(<span class="const">6</span>,<span class="const">2</span>,data);
</pre>

<!-- ################################################################################# -->

<a name="arrays"></a>
<h3>How to create an array of matrices</h3>
<p>
When one needs to create an array of matrices which have undefined size at compilation time, the following solution is available.
</p>
<pre>
   DMatrix *tab = <span class="keyword">new</span> (<span class="const">2</span>,<span class="const">4</span>) DMatrix[<span class="const">10</span>];
</pre>
<p>
which means that <font face="monospace">tab</font> contains an adress of a table of 10 matrices, each of size 2x4.
When the same method is applied to the matrices of fixed dimensions, there will be no effect
</p>
<pre>
   DMatrix4D *tab2 = <span class="keyword">new</span> (<span class="const">5</span>,<span class="const">6</span>) DMatrix4D[<span class="const">10</span>];
</pre>
<p>
The  pointer <font face="monospace">tab2</font> contains the address of a table of 10 matrices each of size 4x4 (the parameters 5,6 are ingorred because type DMatrix4D has fixed size).
</p>


<!-- ################################################################################# -->

<a name="indexing"></a>
<h3>Indexing</h3>
<p>
One can change or access a coefficient in a matrix by using operator() or iterators. The operator() has two arguments - number of row and number of column of the coefficient that is to be accessed. 
Rows and columns are numbered from 1 to the number of rows and the number of columns, respectively. See an example below.
</p>
<pre>
   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="const">1</span>;i&lt;=P.numberOfRows();++i)
   {
      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="const">1</span>;j&lt;=P.numberOfColumns();++j)
      {
         std::cout &lt;&lt; "P(" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; ")=" &lt;&lt; P(i,j) &lt;&lt; std::endl;
         //one can change a coefficient in nonconstant matrix
         P(i,j) = i*j;
         std::cout &lt;&lt; "new value of P(" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; ")=" &lt;&lt; P(i,j) &lt;&lt; std::endl;
      }
   }
</pre>

<!-- ################################################################################# -->

<a name="rowcol"></a>
<h3>Rows and columns of matrices as vectors</h3>
<p>
The rows and columns of a matrix can be seen as vectors.
The vectalg module provides two classes: <font face="monospace">RowVector</font> and <font face="monospace">ColumnVector</font> that 
can be used as references to rows and columns of matrices. Objects of these classes don't have their own allocated memory but only a pointer to 
a proper coefficient in a matrix.
</p>
<p>
These classes have almost the same properties as class <A href="vectorExample.html">Vector</a> (indexing, iterators, normalization), hence they can be used as vectors in generic algorithms.
Objects of these classes are created by methods of class Matrix
</p>
<pre>
   std::cout &lt;&lt; "Reference to first row of matrix Q: " &lt;&lt; Q.row(<span class="const">0</span>) &lt;&lt; std::endl;
   std::cout &lt;&lt; "Reference to first column of matrix Q: " &lt;&lt; Q.column(<span class="const">0</span>) &lt;&lt; std::endl;
   Q.row(<span class="const">0</span>).normalize();
   std::cout &lt;&lt; "After normalization of first row of matrix Q:" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Q=" &lt;&lt; Q &lt;&lt; std::endl;
</pre>
<p>
Rows and columns of a matrix are indexed from zero to number of rows minus 1 and number of columns minus 1, respectively. Class Martix defines two special types for references to rows and columns
</p>
<pre>
   DMatrix::RefRowVectorType r = P.row(<span class="const">0</span>);
   DMatrix::RefColumnVectorType c = P.column(<span class="const">0</span>);
</pre>
<p>
which are useful when one needs to perform many operations on fixed row or column.
</p>

<!-- ################################################################################# -->

<a name="iterators"></a>
<h3>Low level iterators</h3>
<p>
The class Matrix provides low level iterators to a container which stores all the coefficients. They are useful when one needs to perform some operation on each element of a matrix, as in the Hadamard product of two matrices. The following code implements operation Q = Q*P, where symbol '*' denotes the Hadamard product.
</p>
<pre>
   // we assume matrices P and Q have the same dimensions
   DMatrix::iterator b = Q.begin(), e = Q.end(), i=P.begin();
   <span class="keyword">while</span>(b!=e)
   {
      (*b) *= (*i);
      ++b;
      ++i;
   }
</pre>
<p>
Functions <font face="monospace">begin</font> and <font face="monospace">end</font> return low level iterators for the container of a matrix.
</p>
<p>
Const iterators for constant objects are defined in a similar way. An example below computes sum of all numbers in a matrix <font face="monospace">P
</font>
</p>
<pre>
   DMatrix::const_iterator p = P.begin(), k = P.end();
   DMatrix::ScalarType sum(<span class="const">0</span>);
   <span class="keyword">while</span>(p!=k) 
   {
      sum += (*p);
      ++p;
   }
   std::cout &lt;&lt; sum;
</pre>

<!-- ################################################################################# -->

<a name="miterators"></a>
<h3>Matrix iterators</h3>
<p>
One can use in generic algorithms types <font face="monospace">MatrixIterator</font> and <font face="monospace">const_MatrixIterator</font> for manipulating on coefficients in a matrix.
These iterators are returned by functions <font face="monospace">beginMatrix, endMatrix, beginOfRow, endOfRow, beginOfColumn, endOfColumn</font>
</p>  
<pre>
   MatrixIterator&lt;DMatrix&gt; i = P.begin(); // iterator is set to the first coefficient in P
   MatrixIterator&lt;DMatrix&gt; j = P.beginOfRow(<span class="const">1</span>); // iterator is set to the first element in the first row (rows indexed from 1)
   const_MatrixIterator&lt;DMatrix&gt; b = Q.beginOfColumn(<span class="const">2</span>); // iterator is set to the first element in the second column (columns indexed from 1)
   const_MatrixIterator&lt;DMatrix&gt; e = Q.endOfColumn(<span class="const">2</span>);
</pre>
<p>The following member functions are available for moving those iterators</p>
<pre>
   i.moveToNextColumn();
   i.moveToPrevColumn();
   i.moveToNextRow();
   i.moveToPrevRow();
</pre>
<p>One can access a coefficient pointed by iterator by using  operator*</p>
<pre>
   std::cout &lt;&lt; "value pointed by iterator i: " &lt;&lt; (*i) &lt;&lt; std::endl;
</pre>
<p>For more details about <font face="monospace">MatrixIterator</font> and <font face="monospace">const_MatrixIterator</font> see the header file 
<font face="monospace" color="maroon"><b>"capd/vectalg/MatrixIterator.h"</b></font>. 
</p>

<!-- ################################################################################# -->

<a name="basicop"></a>
<h3>Basic operations on matrices</h3>
<p>The following operations on matrices and vectors are available</p>
<pre>
   transposition of a matrix: DMatrix R = Transpose(Q);
   sum: P+R
   subtraction: P-R
   multiplication of two matrices or matices and vectors: Q*R
   multiplication by scalar: 2.*P, P*2.
   multiplication by reference to column or row of a matrix: Q*R.column(<span class="const">0</span>)
</pre>
<p>Moreover, the standard operations like +=, -= etc. whenever possible are available</p>

<!-- ################################################################################# -->

<a name="member"></a>
<h3>Member functions</h3>
<ul>
<li><b>Transpose</b> - if <font face="monospace">Q</font> is a square matrix, it can be transposed by calling 
<pre>
   Q.<span class="funcName">Transpose</span>();
</pre>
</li>
<li><b>clear</b> - this member function assigns zero to each coefficient in the matrix
<pre>
   Q.<span class="funcName">clear</span>();
</pre>
</li>
<li><b>Identity</b> - this static function returns the identity matrix of a given dimension
<pre>
	DMatrix Id = DMatrix::<span class="funcName">Identity</span>(<span class="const">10</span>);
</pre>
</li>
</ul>

<!-- ################################################################################# -->

<a name="imatrix"></a> 
<h3>Operations for interval matrices only</h3>
<p>The following operations are available for interval matrices only - compare similar methods for the class <a href="vectorExample.html#ivectors">Vector</a></p>
<ul>
<li><b>taking a center of a matrix</b>. Function <span class="funcName">midMatrix</span> returns an interval matrix in which each coefficient is the center of the corresponding coefficient (an interval) in argument. 
<pre>
   // create an interval matrix
   interval d1[] = {interval(-1.,1.),interval(2.,2.),interval(3.,3.1), interval(4.,4.1)};
   IMatrix m1(<span class="const">2</span>,<span class="const">2</span>,d1);
   std::cout &lt;&lt; midMatrix(m1) &lt;&lt; std::endl;
   // one should obtain on the screen {{[0,0],[2,2]},{[3.05,3.05],[4.05,4.05]}}
</pre>
</li>
<li><b>splitting</b>. This operation is usefull in Lohner algorithm. The function <font face="monospace"><span class="funcName">split</span>(m1,m2)</font> has two arguments which are modified by this function in the following way (the actual implementation uses equivalent but optimized version):
<pre>
   m2 = m1-midMatrix(m1);
   m1 = midMatrix(m1);
</pre>
After calling (m1 as in the previous example)
<pre>
   split(m1,m2);      
   std::cout &lt;&lt; "m1=" &lt;&lt; m1 &lt;&lt; std::endl;
   std::cout &lt;&lt; "m2=" &lt;&lt; m2 &lt;&lt; std::endl;
</pre>
one should obtain on the screen
<pre>
   m1={{[0,0],[2,2]},{[3.05,3.05],[4.05,4.05]}}
   m2={{[-1,1],[0,0]},{[-0.05,0.05],[-0.05,0.05]}}
</pre>
</li>
</ul>
<hr>
<p><small>Author: Daniel Wilczak, last modified on July 7, 2008.</small></p>

</body>
</html>