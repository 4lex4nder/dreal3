<html>
<head>
<link rel=stylesheet type="text/css" href="../tutorial.css">
</head>
<body>

<h2><span class="keyword">template class</span> Vector&lt;<span class="keyword">typename</span> ScalarType,<span class="keyword">int</span> capacity&gt; - see the <a href="vectorExample.cpp">c++ source</a> of an example</h2>
<p>
This file provides a short description on how to use class Vector from CAPD package - for more details see header file <font face="monospace" color="maroon"><b>"capd/vectalg/Vector.h"</b></font>
</p>
<h3>See also</h3>
<ul>
<li><a href="matrixExample.html">class Matrix</a></li>
<li><a href="normExample.html">class Norm</a></li>
<li><a href="../matrixAlgorithms/matrixAlgorithms.html">matrixAlgorithms module</a> for algorithms on matrices</li>
</ul>

<h3>Content of this file:</h3>
<ul>
<li><a href="#create">How to create a vector</a></li>
<li><a href="#arrays">How to create an array of vectors</a></li>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#basicop">Basic operations on vectors</a></li>
<li><a href="#norms">Norms and normalization</a></li>
<li><a href="#ivectors">Operations for interval vectors only</a></li>
</ul>
<p>
The <span class="keyword">template</span> class Vector is defined in the namespace <span class="keyword">capd::vectalg</span> and it has two parameters - type of elements stored in a vector and capacity.
If capacity is larger than zero, vector is represented as an array of given length inside the object.
If capacity is set to zero, the capacity of a vector must be set when the object is created.
</p>
<p> The following lines define new names for four dimensional vectors </p>
<pre>
   <span class="keyword">typedef</span> Vector&lt;<span class="keyword">double</span>,<span class="const">4</span>&gt; DVector4D;
   <span class="keyword">typedef</span> Vector&lt;interval,<span class="const">4</span>&gt; IVector4D;
</pre>

<p>The following lines define new names for vectors of arbitrary length</p>
<pre>
   <span class="keyword">typedef</span> Vector&lt;<span class="keyword">double</span>,<span class="const">0</span>&gt; DVector;
   <span class="keyword">typedef</span> Vector&lt;interval,<span class="const">0</span>&gt; IVector;
</pre>

<a name="create"></a>
<h3>How to create a vector</h3>
<p> 
the following line creates a four dimensional vector filled with zeros</p>
<pre>
   DVector4D x;
</pre>
<p> <font face="monospace">'y'</font> will be a five dimensional interval vector filled by zeros</p>
<pre>
   IVector y(<span class="const">5</span>);
</pre>
<p>
The following line creates a vector from a given table of numbers.
In fact, the dimension is known, but the interfaces for both types of vectors 
(dynamic table and internal array) are the same - so one must specify the dimension in both cases
</p>
<pre>
   <span class="keyword">double</span> data1[] = {1.,2.,3.,4.};
   <span class="keyword">double</span> data2[] = {4.,3.,2.,1.};
   DVector4D a(<span class="const">4</span>,data1);
   DVector4D b(<span class="const">4</span>,data2);
</pre>

<a name="arrays"></a>
<h3>How to create an array of vectors</h3>
<p>
When one needs to create an array of vectors which has undefined dimension at compilation time, 
the following solution is available. The class Vector has a static function which sets default
dimension for all objects that will be created by default constructor
</p>

<pre>
   DVector::setDefaultDimension(<span class="const">5</span>);
   DVector *tab = new DVector[<span class="const">6</span>];
   // using an array
   <span class="keyword">delete</span> []tab;
</pre>
<p>
The above can be also written in short form
</p>
<pre>
   tab = <span class="keyword">new</span> (<span class="const">5</span>) DVector[<span class="const">6</span>];
</pre>
<p>
which means that <font face="monospace">tab</font> contains an address of a table of six vectors, each of dimension 5.
When the same methods are applied to vectors of fixed dimension, there is no effect, i.e. all vectors in array will have dimension as specified in argument of template.
</p>
<pre>
   DVector4D *tab2 = <span class="keyword">new</span> (<span class="const">5</span>) DVector4D[<span class="const">6</span>];
</pre>
<p>The dimension of vectors in array <font face="monospace">tab2</font> is 4.</p>


<a name="indexing"></a>
<h3>Indexing</h3>
<p>
One can change or access a coefficient in a vector by using operator[] or iterators. The following operations are available for vectors <font face="monospace">a,b</font>
</p>
<pre>
   std::cout &lt;&lt; b[i]; // prints on the screen i-th coordinate of a vector b
   a[i] = i*i;        // sets i-th coordinate of a vector 'a' to be equal to i*i
</pre>
<p>
The index <font face="monospace">'i'</font> should be between 0 and the dimension of a vector minus 1, which can be easily obtained by a member function <font face="monospace">dimension</font> as in the example below
<pre>      
   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="const">0</span>;i&lt;a.dimension();++i)
   {
      std::cout &lt;&lt; "a[" &lt;&lt; i &lt;&lt; "]=" &lt;&lt; a[i] &lt;&lt; std::endl;
      //one can set a coefficient in nonconstant vector
      a[i] = i*i;
      std::cout &lt;&lt; "New value of a[" &lt;&lt; i &lt;&lt; "]=" &lt;&lt; a[i] &lt;&lt; std::endl;
   }
</pre>

<a name="iterators"></a>
<h3>Iterators</h3>
<p> 
The other proposed way to access a coefficient in a vector is to use iterators instead of indexing. Class Vector provides type definitions for iterators and constant iterators.
</p>
<pre>
   DVector::iterator bg = b.begin(), en = b.end();
   <span class="keyword">while</span>(bg!=en) 
   {
      std::cout &lt;&lt; "value of an iterator: " &lt;&lt; bg &lt;&lt; "\ncoefficient in a vector: " &lt;&lt; (*bg) &lt;&lt; std::endl;
      ++bg;
   }
</pre>
<p>
Constant iterators for constant objects are defined in the similar way
<pre>
   <span class="keyword">const</span> DVector c(<span class="const">4</span>,data1);
   DVector::const_iterator p = c.begin(), k = c.end();
   std::cout &lt;&lt; "\nCoefficients in constant vector:\n";
   <span class="keyword">while</span>(p!=k) 
   {
      std::cout &lt;&lt; (*p) &lt;&lt; std::endl;
      ++p;
   }
</pre>      

<a name="basicop"></a>
<h3>Basic operations on vectors</h3>

<p>The following standard operations on vectors are available</p>
<pre>
   sum: a+b
   subtraction: a-b
   euclidean scalar product: a*b
   multiplication by scalar: 2*a, a*2
   unary operator: -a
   equality: a==b, a!=b
</pre>
<p>Moreover, the standard operations like +=, -= etc. are available when possible</p>

<a name="norms"</a>
<h3>Norms and normalization</h3>
<p>The euclidean norm of a vector can be computed be using member function <font face="monospace">euclNorm</font>
<pre>      
   std::cout &lt;&lt; "euclidean norm of b: " &lt;&lt; b.euclNorm() &lt;&lt; std::endl;
</pre>
<p>The vector can be normalized with respect to the euclidean norm by calling member function <font face="monospace">normalize</font>
<pre>
   a.normalize();
   std::cout &lt;&lt; "normalization with respect to euclidean norm of vector a: " &lt;&lt; a &lt;&lt; std::endl;
</pre>   
   

<a name="ivectors"></a>
<h3>Operations for interval vectors only</h3>
<p>Many operations are suitable for interval vectors only. The most important are</p>
<ul>
<li><b>taking a center of an interval vector</b>. Function <span class="funcName">midVector</span> returns an interval vector in which each coefficient is the center of the corresponding coefficient 
(an interval) in argument. 
<pre>
   // create an interval vector
   interval d1[] = {interval(-1.,1.),interval(2.,2.),interval(3.,3.1), interval(4.,4.1)};
   IVector v1(<span class="const">4</span>,d1);
   std::cout &lt;&lt; midVector(v1);
   // on the screen should be {[0,0],[2,2],[3.05,3.05],[4.05,4.05]}
</pre>
</li>

<li> <b>splitting</b> - this operation is useful in Lohner algorithm. The function <font face="monospace"><span class="funcName">split</span>(v1,v2)</font> has two arguments, which are modified by this function in the following way (the actual implementation uses equivalent but optimized version):
<pre>
   v2 = v1-midVector(v1);
   v1 = midVector(v1);
</pre>
<p>After calling</p>
<pre>
   // assume v1 is as in the previous example
   split(v1,v2);      
   std::cout &lt;&lt; "v1=" &lt;&lt; v1 &lt;&lt; std::endl;
   std::cout &lt;&lt; "v2=" &lt;&lt; v2 &lt;&lt; std::endl;
</pre>      
one should obtain on the screen 
<pre>
   v1={[0,0],[2,2],[3.05,3.05],[4.05,4.05]}
   v2={[-1,1],[0,0],[-0.05,0.05],[-0.05,0.05]}
</pre>
</li>

<li><b>taking the left and right vectors</b>. Functions <span class="funcName">leftVector,rightVector</span> return vector of left or right ends, respectively.
After calling (with v2 as above)
<pre>
   std::cout &lt;&lt; "\nleftVector(v2)= " &lt;&lt; leftVector(v2) &lt;&lt; std::endl;
   std::cout &lt;&lt; "rightVector(v2)= " &lt;&lt; rightVector(v2) &lt;&lt; std::endl;
</pre>
one should obtain on the screen
<pre>
   leftVector(v2)= {[-1,-1],[0,0],[-0.05,-0.05],[-0.05,-0.05]}
   rightVector(v2)= {[1,1],[0,0],[0.05,0.05],[0.05,0.05]}
</pre>
</li>

<li><b>diameter of a vector</b>. This operation returns a vector which contains diameter of each coefficient in the argument.
After calling (with v2 as above)
<pre>
   std::cout &lt;&lt; "diam(v2) = " &lt;&lt; <span class="funcName">diam</span>(v2) &lt;&lt; std::endl;
</pre>
one should obtain
<pre>
   diam(v2) = {[2,2],[0,0],[0.1,0.1],[0.1,0.1]}
</pre>
</li>

<li><b>inclusions</b>. There are two functions for verifying inclusions of vectors. 
Function <font face="monospace"><span class="funcName">subset</span>(v1,v2)</font> verifies if the set represented as interval vector <font face="monospace">v1</font> is a subset of <font face="monospace">v2</font>.
<br>
Similar function <font face="monospace"><span class="funcName">subsetInterior</span>(v1,v2)</font> verifies if <font face="monospace">v1</font> is a subset of the interior of <font face="monospace">v2</font>.
</li>

<li><b>intersections</b>. The function 
<pre>
   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IVector&gt;
   IVector intersection(<span class="keyword">const</span> IVector&amp; x, <span class="keyword">const</span> IVector&amp; y);
</pre>
returns an intersection of two interval vectors or throws an exception if this intersection is empty.
</li>
</ul>
<hr>
<p><small>Author: Daniel Wilczak, last modified on July 7, 2008.</small></p>

</body>
</html>