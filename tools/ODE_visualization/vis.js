// Generated by CoffeeScript 1.6.1
(function() {
  var Chart, addTimeToData, animation_delay, color, contextHeight, contextWidth, createChart, height, margin, processJson, showOnly, svg, width;

  color = d3.scale.category10();

  animation_delay = 800;

  showOnly = function(chart, b) {
    chart.xScale.domain(b);
    chart.chartContainer.selectAll("rect").data(chart.chartData).attr("x", function(d) {
      return chart.xScale(d.domX[0]) + .5;
    }).attr("width", function(d) {
      return chart.xScale(d.domX[1]) - chart.xScale(d.domX[0]) - .5;
    });
    chart.chartContainer.selectAll("line").data(chart.chartData).attr("x1", function(d) {
      return chart.xScale(d.domX[0]) + .5;
    }).attr("x2", function(d) {
      return chart.xScale(d.domX[0]) + .5;
    });
    chart.chartContainer.selectAll("path.chart").attr("d", chart.area);
    chart.chartContainer.selectAll("path.line").attr("d", chart.line);
    if (chart.id === 0) {
      chart.chartContainer.select(".x.axis.top").call(chart.xAxisTop);
    }
    return chart.chartContainer.select(".x.axis.bottom").call(chart.xAxisBottom);
  };

  addTimeToData = function(t, item) {
    item.values = item.values.map(function(data) {
      var ret;
      ret = {};
      ret.time = [+data.time[0] + t[1], +data.time[1] + t[1]];
      ret.enclosure = data.enclosure;
      return ret;
    });
    return item;
  };

  processJson = function(json) {
    var data, groups, k, lastTime, result, trace, traces;
    groups = json.groups;
    json.traces = _.rest(json.traces);
    traces = _.filter(json.traces, function(item) {
      return _.some(groups, function(g) {
        return (+item[0].group) === g;
      });
    });
    result = [];
    traces.forEach(function(trace) {
      return trace.forEach(function(piece) {
        var k, key_strings, s;
        key_strings = piece.key.split("_");
        piece.mode = _.last(key_strings);
        key_strings = _.initial(key_strings);
        s = piece.step = _.last(key_strings);
        key_strings = _.initial(key_strings);
        k = piece.key = key_strings.join("_");
        if (!(k in result)) {
          result[k] = new Array();
        }
        if (!(s in result[k])) {
          result[k][s] = new Array();
        }
        result[k][s] = piece;
        return result[k].key = k;
      });
    });
    lastTime = [];
    for (k in result) {
      trace = result[k];
      _.each(trace, function(piece) {
        if (!(k in lastTime)) {
          lastTime[k] = [0.0, 0.0];
        }
        piece = addTimeToData(lastTime[k], piece);
        lastTime[k] = _.last(piece.values).time;
        return piece.domX = [
          d3.min(piece.values, function(d) {
            return d.time[0];
          }), d3.max(piece.values, function(d) {
            return d.time[1];
          })
        ];
      });
      trace.domX = [
        d3.min(trace, function(piece) {
          return piece.domX[0];
        }), d3.max(trace, function(piece) {
          return piece.domX[1];
        })
      ];
      trace.domY = [
        d3.min(trace, function(piece) {
          return d3.min(piece.values, function(d) {
            return d.enclosure[0];
          });
        }), d3.max(trace, function(piece) {
          return d3.max(piece.values, function(d) {
            return d.enclosure[1];
          });
        })
      ];
    }
    data = {};
    data.title = json.title;
    data.values = _.values(result);
    data.domX = [
      d3.min(data.values, function(trace) {
        return trace.domX[0];
      }), d3.max(data.values, function(trace) {
        return trace.domX[1];
      })
    ];
    data.domY = [
      d3.min(data.values, function(trace) {
        return trace.domY[0];
      }), d3.max(data.values, function(trace) {
        return trace.domY[1];
      })
    ];
    return data;
  };

  createChart = function(json) {
    var brush, chartHeight, charts, context, contextArea, contextAxis, contextLine, contextXScale, contextYScale, data, keys, onBrush;
    data = processJson(json);
    charts = [];
    keys = data.values.length;
    chartHeight = height * (1 / keys);
    contextXScale = d3.scale.linear().range([0, contextWidth]).domain(data.domX);
    contextYScale = d3.scale.linear().range([contextHeight, 0]).domain(data.domY);
    contextAxis = d3.svg.axis().scale(contextXScale).tickSize(contextHeight).tickPadding(-10).orient("bottom");
    contextArea = d3.svg.area().interpolate("monotone").x0(function(p) {
      return contextXScale(p.time[0]);
    }).x1(function(p) {
      return contextXScale(p.time[1]);
    }).y0(function(p) {
      return contextYScale(p.enclosure[0]);
    }).y1(function(p) {
      return contextYScale(p.enclosure[1]);
    });
    contextLine = d3.svg.line().interpolate("monotone").x(function(p) {
      return contextXScale((p.time[0] + p.time[1]) / 2);
    }).y(function(p) {
      return contextYScale((p.enclosure[0] + p.enclosure[1]) / 2);
    });
    context = svg.append("g").attr("class", "context").attr("transform", "translate(" + (0 + margin.left) + "," + (chartHeight * keys + margin.top + margin.bottom) + ")");
    context.append("g").attr("class", "x axis top").attr("transform", "translate(0,0)").call(contextAxis);
    _.each(data.values, function(data, i) {
      return charts.push(new Chart({
        data: data,
        id: i,
        name: data.key,
        width: width,
        height: height * (1 / keys),
        domainX: data.domainX,
        svg: svg,
        margin: margin,
        context: context,
        contextArea: contextArea,
        contextLine: contextLine
      }));
    });
    context.append("text").attr("class", "instructions").attr("transform", "translate(0," + (contextHeight + 20) + ")").text('Click and drag above to zoom / pan the data');
    onBrush = function() {
      var b, i, _i, _results;
      b = brush.empty() ? contextXScale.domain() : brush.extent();
      _results = [];
      for (i = _i = 0; _i < keys; i = _i += 1) {
        _results.push(showOnly(charts[i], b));
      }
      return _results;
    };
    brush = d3.svg.brush().x(contextXScale).on("brush", onBrush);
    return context.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("y", 0).attr("height", contextHeight);
  };

  Chart = (function() {

    function Chart(data) {
      var chart, chartContainer, maxY, minY, tickDom, tickVal, tickValCard, xS, yS;
      this.chartData = data.data;
      this.width = data.width;
      this.height = data.height;
      this.domX = data.domX;
      this.modes = data.modes;
      this.svg = data.svg;
      this.id = data.id;
      this.name = data.name;
      this.margin = data.margin;
      this.xScale = d3.scale.linear().range([0, this.width]).domain(this.chartData.domX);
      minY = d3.min(this.chartData, function(p) {
        return p.domX[0];
      });
      maxY = d3.max(this.chartData, function(p) {
        return p.domX[1];
      });
      this.yScale = d3.scale.linear().range([this.height, 0]).domain(this.chartData.domY);
      xS = this.xScale;
      yS = this.yScale;
      chart = this;
      this.line = d3.svg.line().interpolate("basis").x(function(p) {
        return xS((p.time[0] + p.time[1]) / 2);
      }).y(function(p) {
        return yS((p.enclosure[0] + p.enclosure[1]) / 2);
      });
      this.area = d3.svg.area().interpolate("basis").x0(function(p) {
        return xS(p.time[0]);
      }).x1(function(p) {
        return xS(p.time[1]);
      }).y0(function(p) {
        return yS(p.enclosure[0]);
      }).y1(function(p) {
        return yS(p.enclosure[1]);
      });
      this.svg.append("defs").append("clipPath").attr("id", "clip-" + this.id).append("rect").attr("width", this.width).attr("height", this.height);
      chartContainer = this.chartContainer = svg.append("g").attr('class', this.name.toLowerCase()).attr("transform", "translate(" + this.margin.left + "," + (this.margin.top + (this.height * this.id) + (20 * this.id)) + ")");
      this.chartContainer.selectAll("rect").data(this.chartData).enter().append("svg:rect").on("mouseover", function(d) {
        return d3.select(this).transition().style("fill-opacity", 0.5);
      }).on("mouseout", function(d) {
        return d3.select(this).transition().style("fill-opacity", 0.2);
      }).attr("x", function(d) {
        return xS(d.domX[0]) + .5;
      }).attr("y", 0).attr("height", this.height).attr("width", function(d) {
        return xS(d.domX[1]) - xS(d.domX[0]) - .5;
      }).attr("fill", function(d) {
        return d3.rgb(color(d.key)).brighter(d.mode * 2);
      }).style("fill-opacity", 0.0).transition().duration(function(d) {
        return animation_delay * (+d.step + 1);
      }).style("fill-opacity", 0.3).transition().duration(function(d) {
        return animation_delay / 10 * (+d.step + 1);
      }).style("fill-opacity", 0.2).attr("clip-path", "url(#clip-" + this.id + ")");
      this.chartContainer.selectAll("line").data(this.chartData).enter().append("svg:line").attr("x1", function(d) {
        return xS(d.domX[1]) + .5;
      }).attr("x2", function(d) {
        return xS(d.domX[1]) + .5;
      }).attr("y1", 0).attr("y2", this.height).style("stroke", "#999999").style("stroke-width", "0.5px").attr("clip-path", "url(#clip-" + this.id + ")");
      _.each(this.chartData, function(piece) {
        return chart.chartContainer.append("path").data([piece.values]).attr("class", "chart").attr("clip-path", "url(#clip-" + chart.id + ")").attr("d", chart.area).style("fill-opacity", 0.0).transition().duration(animation_delay * (+piece.step + 1)).style("fill", color(piece.key)).style("fill-opacity", 0.8);
      });
      _.each(this.chartData, function(piece) {
        return chart.chartContainer.append("path").data([piece.values]).attr("class", "line").attr("clip-path", "url(#clip-" + chart.id + ")").style("stroke", color(piece.key)).style("stroke-width", "2px").style("fill-opacity", 0.0).style("stroke-opacity", 0.0).transition().duration(animation_delay * (+piece.step + 1)).style("stroke-opacity", 1.0).attr("d", chart.line);
      });
      _.each(this.chartData, function(piece) {
        return data.context.append("path").data([piece.values]).attr("class", "chart").attr("d", data.contextArea).style("fill", "black").style("fill-opacity", 0.1);
      });
      _.each(this.chartData, function(piece) {
        return data.context.append("path").data([piece.values]).attr("d", data.contextLine).style("stroke", color(piece.key)).style("stroke-width", "2px").style("fill-opacity", 0.0);
      });
      tickVal = _.map(data.data, function(d) {
        return (d3.min(d.values, function(item) {
          return item.time[0];
        }) + d3.max(d.values, function(item) {
          return item.time[1];
        })) / 2;
      });
      tickDom = [d3.min(tickVal), d3.max(tickVal)];
      tickValCard = tickDom[1] - tickDom[0];
      if (this.id === 0) {
        this.xAxisTop = d3.svg.axis().scale(this.xScale).tickSize(0).tickValues(tickVal).tickFormat(function(n, i) {
          return "Mode" + data.data[i].mode;
        }).orient("bottom");
      }
      this.xAxisBottom = d3.svg.axis().scale(this.xScale).orient("bottom");
      if (this.id === 0) {
        this.chartContainer.append("g").attr("class", "x axis top").attr("transform", "translate(0,0)").call(this.xAxisTop);
      }
      chartContainer.append("g").attr("class", "x axis bottom").attr("transform", "translate(0," + this.height + ")").call(this.xAxisBottom);
      this.yAxis = d3.svg.axis().scale(this.yScale).orient("left").ticks(5);
      chartContainer.append("g").attr("class", "y axis").attr("transform", "translate(0,0)").call(this.yAxis);
      this.chartContainer.append("text").attr("class", "country-title").attr("transform", "translate(15,40)").text(this.name);
    }

    return Chart;

  })();

  margin = {
    top: 10,
    right: 40,
    bottom: 100,
    left: 60
  };

  width = 940 - margin.left - margin.right;

  height = 500 - margin.top - margin.bottom;

  contextHeight = 50;

  contextWidth = width;

  svg = d3.select("#chart-container").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom + 200);

  d3.json('data.json', createChart);

}).call(this);
